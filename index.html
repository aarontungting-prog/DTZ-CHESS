è¥¿æ´‹æ£‹å®Œæ•´V.1

<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>éœ“è™¹è¥¿æ´‹æ£‹ï¼šDTZ å–®æª”çµ‚æ¥µç‰ˆ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
        }
    }
    </script>

    <style>
        /* =========================================
           1. å…¨åŸŸè¨­å®š (Global)
           ========================================= */
        body { 
            margin: 0; padding: 0; overflow: hidden; 
            background: #000; 
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif; 
            touch-action: none; color: white; 
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 0;
            outline: none;
        }

        #ui { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; 
            z-index: 100; 
        }

        .hud { pointer-events: auto; }

        /* æ‰‹æ©Ÿé¸å–®æŒ‰éˆ•é è¨­éš±è— */
        #mobile-menu-btn { display: none; }

        .hud-container {
            position: absolute; top: 20px; left: 20px; 
            display: flex; flex-direction: column; gap: 15px;
            width: 260px; pointer-events: auto;
        }

        .hud-box {
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #444; 
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            backdrop-filter: blur(2px);
        }

        .user-card-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .name-text { font-weight: bold; font-size: 16px; color: #fff; display: block; }
        .elo-text { font-size: 12px; color: #888; margin-bottom: 10px; }
        .elo-text span { color: #00e5ff; font-weight: bold; }
        .custom-btn {
            width: 100%; padding: 8px; background: #222; border: 1px solid #444;
            color: #ccc; border-radius: 6px; cursor: pointer; font-size: 13px; transition: 0.2s;
        }
        .custom-btn:hover { background: #333; color: #fff; border-color: #666; }

        .lobby-title { color: #aaa; font-size: 12px; letter-spacing: 1px; margin-bottom: 8px; text-transform: uppercase; font-weight: bold; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .room-status { font-size: 14px; color: #00ff00; margin-bottom: 12px; font-weight: bold; text-shadow: 0 0 5px rgba(0, 255, 0, 0.5); }
        .separator { height: 1px; background: #333; margin: 12px 0; }
        .logout-btn { background: transparent; color: #666; border: none; font-size: 12px; width: 100%; cursor: pointer; }
        .logout-btn:hover { color: #aaa; }

        /* ç™»å…¥ä»‹é¢ */
        #auth-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3); z-index: 2000; 
            display: flex; justify-content: center; align-items: center; 
            pointer-events: auto; backdrop-filter: blur(3px);
        }
        .auth-box {
            background: rgba(15, 15, 20, 0.9); border: 1px solid #00e5ff;
            padding: 30px; border-radius: 12px; width: 300px;
            text-align: center; box-shadow: 0 0 50px rgba(0, 229, 255, 0.3);
        }
        .auth-box h2 { color: #00e5ff; margin-top: 0; letter-spacing: 2px; font-size: 24px; margin-bottom: 20px; }
        .auth-input { 
            width: 100%; padding: 12px; margin: 8px 0; 
            background: rgba(0,0,0,0.5); border: 1px solid #444; 
            color: #fff; border-radius: 6px; box-sizing: border-box; font-size: 16px; 
        }
        .auth-input:focus { border-color: #00e5ff; outline: none; background: rgba(0,0,0,0.8); }
        .auth-btn { width: 100%; padding: 12px; margin-top: 15px; background: #00e5ff; color: #000; border: none; font-weight: bold; cursor: pointer; border-radius: 6px; transition: 0.3s; font-size: 16px; }
        .guest-btn { width: 100%; padding: 10px; margin-top: 10px; background: transparent; color: #aaa; border: 1px solid #444; font-weight: bold; cursor: pointer; border-radius: 6px; transition: 0.3s; font-size: 14px; }
        #nickname-container { display: none; }
        .forgot-link { display: block; margin-top: 15px; color: #aaa; font-size: 12px; cursor: pointer; }

        /* å³ä¸Šè§’ç‹€æ…‹é¢æ¿ */
        #status-panel { top: 20px; right: 20px; text-align: right; background: linear-gradient(to left, rgba(0, 255, 255, 0.1), rgba(0,0,0,0)); padding: 15px; border-right: 3px solid #00e5ff; }
        h1 { margin: 0; font-size: 1.2rem; letter-spacing: 2px; color: #00e5ff; margin-bottom: 5px; }
        #turn-txt { font-size: 1.5rem; font-weight: 900; color: #fff; }

        /* å´é‚Šé¢æ¿ */
        .side-panel {
            position: fixed; top: 0; left: 0; bottom: 0; width: 320px;
            background: rgba(12, 12, 18, 0.98); border-right: 1px solid #00e5ff;
            box-shadow: 10px 0 50px rgba(0, 0, 0, 0.8);
            transform: translateX(-105%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1200; padding: 25px; overflow-y: auto; pointer-events: auto;
        }
        .side-panel.active { transform: translateX(0); }
        .side-panel h2 { color: #00e5ff; margin-top: 0; border-bottom: 1px solid #333; padding-bottom: 15px; margin-bottom: 20px; font-size: 20px; }
        .custom-section { margin-bottom: 30px; }
        .custom-section h3 { font-size: 14px; color: #888; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }

        .avatar-preview-container { width: 100px; height: 100px; margin: 0 auto 15px auto; position: relative; border-radius: 12px; background: #111; cursor: pointer; overflow: hidden; border: 2px solid #333; }
        .avatar-img { width: 100%; height: 100%; object-fit: cover; }
        #avatar-hint { position: absolute; bottom: 0; width: 100%; text-align: center; background: rgba(0,0,0,0.7); font-size: 10px; padding: 3px 0; color: #fff; transform: translateY(100%); transition: 0.3s; }
        .avatar-preview-container:hover #avatar-hint { transform: translateY(0); }
        .avatar-frame { position: absolute; top: -5px; left: -5px; right: -5px; bottom: -5px; border-radius: 12px; border: 3px solid transparent; pointer-events: none; box-shadow: 0 0 15px rgba(0,0,0,0.5); }
        .skin-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 10px; }
        .skin-item { background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 10px; text-align: center; cursor: pointer; transition: 0.2s; position: relative; }
        .skin-item:hover { background: #222; border-color: #666; }
        .skin-item.selected { border-color: #00e5ff; background: rgba(0, 229, 255, 0.1); box-shadow: 0 0 10px rgba(0, 229, 255, 0.2); }
        .skin-item.locked { opacity: 0.5; cursor: not-allowed; }
        .skin-icon { font-size: 24px; margin-bottom: 5px; }
        .skin-name { font-size: 10px; color: #aaa; }
        .skin-item.selected .skin-name { color: #00e5ff; font-weight: bold; }

        .frame-bronze { border-color: #cd7f32; }
        .frame-silver { border-color: #c0c0c0; box-shadow: 0 0 10px #c0c0c0; }
        .frame-gold { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; }
        .frame-diamond { border-color: #b9f2ff; box-shadow: 0 0 20px #b9f2ff, inset 0 0 10px #b9f2ff; }
        .frame-master { border-color: #ff0055; box-shadow: 0 0 25px #ff0055, inset 0 0 15px #ff0055; animation: pulse 2s infinite; }

        .custom-input { width: 100%; padding: 10px; background: #1a1a1a; border: 1px solid #333; color: #fff; border-radius: 4px; box-sizing: border-box; margin-bottom: 10px; outline: none; }
        .custom-input:focus { border-color: #00e5ff; }
        .small-btn { background: #333; border: 1px solid #555; color: #fff; cursor: pointer; border-radius: 4px; padding: 8px 12px; font-size: 12px; white-space: nowrap;}
        .save-btn { margin-top: 20px; }
        .mini-avatar { width: 45px; height: 45px; border-radius: 8px; border: 2px solid #333; object-fit: cover; }

        #loading { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; justify-content: center; align-items: center; color: #00e5ff; font-weight: bold; z-index: 1500; }
        #footer-watermark { position: absolute; bottom: 10px; width: 100%; text-align: center; color: rgba(255,255,255,0.3); font-size: 12px; }

        button.game-btn { background: #00e5ff; color: #000; border: none; padding: 10px; margin-top: 8px; width: 100%; font-weight: bold; cursor: pointer; transition: 0.3s; border-radius: 4px; }
        button.join-btn { background: #ff0055; color: #fff; }
        button.game-btn:hover { filter: brightness(1.1); transform: translateY(-1px); }

        #menu-backdrop { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 900; pointer-events: auto; }
        #menu-backdrop.active { display: block; }

        /* =========================================
           2. æ‰‹æ©Ÿç‰ˆå°ˆç”¨è¨­å®š (Mobile Overrides)
           ========================================= */
        @media (max-width: 600px) {
            #mobile-menu-btn { 
                display: flex; 
                position: absolute; 
                bottom: 30px; left: 20px; 
                width: 50px; height: 50px; 
                background: rgba(0,0,0,0.8); 
                border: 2px solid #00e5ff; 
                border-radius: 50%; 
                color: #00e5ff; 
                justify-content: center; align-items: center; 
                font-size: 14px; 
                cursor: pointer; 
                z-index: 3000; 
                pointer-events: auto; 
                box-shadow: 0 0 15px rgba(0,229,255,0.5);
                font-weight: bold;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
            }

            .hud-container { 
                display: flex; 
                width: 100%; box-sizing: border-box;
                position: fixed; top: auto; bottom: 0; left: 0;
                transform: translateY(110%); 
                z-index: 2500; 
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                padding: 10px 20px 80px 20px; 
                background: rgba(10, 10, 15, 0.95);
                border-top: 2px solid #00e5ff;
                pointer-events: auto;
            }

            .hud-container.mobile-visible {
                transform: translateY(0);
            }

            .hud-box {
                background: transparent; border: none; box-shadow: none; padding: 0; margin-bottom: 10px;
            }
            .profile-box { border-bottom: 1px solid #333; padding-bottom: 10px; }
            
            #status-panel { 
                top: 15px; left: 50%; transform: translateX(-50%); width: auto; 
                background: rgba(0,0,0,0.6); border-radius: 30px; padding: 5px 20px; 
                white-space: nowrap; right: auto; border: 1px solid #333;
                z-index: 2000;
            }
            #status-panel h1 { display: none; }

            .side-panel { width: 90%; }
        }
    </style>
</head>
<body>

<div id="loading">æ­£åœ¨è¼‰å…¥éœ“è™¹ä¸–ç•Œ...</div>

<div id="auth-modal">
    <div class="auth-box">
        <h2>DTZ CHESS</h2>
        <div id="auth-error" style="color:#ff0055; font-size:12px; margin-bottom:10px;"></div>
        
        <div id="email-login-form">
            <input type="email" id="email" class="auth-input" placeholder="é›»å­ä¿¡ç®±">
            <input type="password" id="password" class="auth-input" placeholder="å¯†ç¢¼">
            <div id="nickname-container">
                <input type="text" id="nickname" class="auth-input" placeholder="è¨­å®šæ‚¨çš„æš±ç¨±">
            </div>
            <button id="auth-action-btn" class="auth-btn">é€²å…¥ä¸–ç•Œ</button>
            <div class="forgot-link" id="forgot-pw">å¿˜è¨˜å¯†ç¢¼ï¼Ÿ</div>
        </div>
        
        <button id="guest-btn" class="guest-btn">è¨ªå®¢ç™»å…¥</button>
    </div>
</div>

<div id="ui" style="display:none;">
    
    <div id="mobile-menu-btn" onclick="toggleMenu()">â˜° é¸å–®</div>
    <div id="menu-backdrop" onclick="closeAllMenus()"></div>

    <div id="menu-panel" class="hud-container">
        <div class="hud-box profile-box">
            <div class="user-card-header">
                <img id="hud-avatar" src="" class="mini-avatar">
                <div class="user-info">
                    <span id="user-name" class="name-text">Player</span>
                    <span id="user-rank" class="rank-badge rank-bronze">éŠ…ç‰Œ</span>
                </div>
            </div>
            <div class="elo-text">
                æˆ°åŠ›ç©åˆ† (ELO): <span id="user-elo">0</span>
            </div>
            <button id="btn-custom" class="custom-btn">ğŸ› ï¸ å€‹äººåŒ–è¨­å®š</button>
        </div>

        <div class="hud-box action-box">
            <div class="lobby-title">å°æˆ°å¤§å»³</div>
            <div id="room-display" class="room-status">ç‹€æ…‹ï¼šé–’ç½®ä¸­</div>
            
            <div id="lobby-buttons">
                <button id="btn-create" class="game-btn">å‰µå»ºæˆ¿é–“ (åŸ·ç™½)</button>
                <button id="btn-join" class="game-btn join-btn">åŠ å…¥æˆ¿é–“ (åŸ·é»‘)</button>
            </div>

            <button id="btn-leave" class="game-btn" style="display:none; background:#0088ff; color:white; margin-top:10px;">é€€å‡ºæˆ¿é–“ / çµæŸé€£ç·š</button>
            
            <div class="separator"></div>
            <button id="btn-logout" class="logout-btn">ç™»å‡º</button>
        </div>
    </div>

    <div id="custom-panel" class="side-panel">
        <h2>å€‹äººåŒ–è¨­å®š</h2>
        
        <div class="custom-section">
            <h3>ğŸ‘¤ æŒ‡æ®å®˜è­˜åˆ¥è­‰</h3>
            <div class="avatar-preview-container" onclick="triggerAvatarUpload()">
                <img id="my-avatar" src="" alt="Avatar" class="avatar-img">
                <div id="my-frame" class="avatar-frame"></div>
                <input type="file" id="avatar-upload" accept="image/*" style="display: none;">
                <div id="avatar-hint">æ›´æ›åœ–ç‰‡</div>
            </div>
            <div id="guest-avatar-controls">
                <div style="display:flex; gap:5px; margin-bottom: 10px;">
                    <input type="text" id="avatar-seed" class="custom-input" placeholder="è¼¸å…¥ä»£ç¢¼" style="margin:0;">
                    <button id="btn-random-avatar" class="small-btn">ğŸ² éš¨æ©Ÿ</button>
                </div>
            </div>
            <label>é¡¯ç¤ºæš±ç¨±:</label>
            <input type="text" id="edit-name" class="custom-input">
        </div>

        <div class="custom-section">
            <h3>â™Ÿï¸ æ£‹å­æ¨¡å‹ (Skins)</h3>
            <div class="skin-grid" id="piece-skin-grid">
                <div class="skin-item selected" onclick="previewSkin('piece', 'neon', this)">
                    <div class="skin-icon">ğŸ’ </div>
                    <div class="skin-name">é›»é¦­éœ“è™¹</div>
                </div>
                <div class="skin-item" onclick="previewSkin('piece', 'classic', this)">
                    <div class="skin-icon">â™Ÿï¸</div>
                    <div class="skin-name">ç¶“å…¸å¯¦é«”</div>
                </div>
                <div class="skin-item locked">
                    <div class="skin-icon">ğŸ”’</div>
                    <div class="skin-name">æ•¬è«‹æœŸå¾…</div>
                </div>
            </div>
            <input type="hidden" id="selected-piece-style" value="neon">
        </div>

        <div class="custom-section">
            <h3>ğŸ”² æˆ°å ´æè³ª (Map)</h3>
            <div class="skin-grid" id="board-skin-grid">
                <div class="skin-item selected" onclick="previewSkin('board', 'neon', this)">
                    <div class="skin-icon">ğŸŒŒ</div>
                    <div class="skin-name">å…¨æ¯æŠ•å½±</div>
                </div>
                <div class="skin-item locked">
                    <div class="skin-icon">ğŸ”’</div>
                    <div class="skin-name">æ•¬è«‹æœŸå¾…</div>
                </div>
            </div>
            <input type="hidden" id="selected-board-style" value="neon">
        </div>
        
        <button id="btn-save-custom" class="game-btn save-btn">ä¿å­˜ä¸¦å¥—ç”¨</button>
        <button onclick="closeAllMenus()" class="game-btn" style="background:#333; margin-top:10px;">é—œé–‰é¢æ¿</button>
    </div>

    <div id="status-panel" class="hud">
        <h1>NEON CHESS</h1>
        <div id="turn-txt">ç­‰å¾…å°æˆ°</div>
        <div id="opponent-info" style="font-size: 12px; color: #aaa; margin-top:5px;">å°æ‰‹: ---</div>
    </div>
    <div id="footer-watermark">Made by DTZ</div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getDatabase, ref, set, get, update, onValue, off, remove } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
    import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signInAnonymously, onAuthStateChanged, signOut, sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { Sky } from 'three/addons/objects/Sky.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const CONFIG = {
        grassCount: isMobile ? 5000 : 80000,
        treeCount: isMobile ? 50 : 850,
        shadowSize: isMobile ? 512 : 2048, 
        pixelRatio: isMobile ? Math.min(window.devicePixelRatio, 1.2) : window.devicePixelRatio
    };

    let scene, camera, renderer, controls, raycaster, mouse, clock;
    let grassMat, cloudParticles = [];
    let tilesMap = {}, piecesMap = {};
    let visSelectedSq = null; 
    let customModels = null;
    const BOARD_HEIGHT = 15;
    let currentSettings = { pieceStyle: 'neon', boardStyle: 'neon' };
    let isLoginRotating = false; 
    let opponentCursorMesh = null;

    const GEOMETRIES = {
        cylBase: new THREE.CylinderGeometry(0.4, 0.45, 0.2, 32),
        pawnBody: new THREE.CylinderGeometry(0.15, 0.35, 0.6, 16),
        pawnHead: new THREE.SphereGeometry(0.25, 32, 32),
        rookBody: new THREE.CylinderGeometry(0.35, 0.35, 0.8, 32),
        rookHead: new THREE.CylinderGeometry(0.4, 0.4, 0.3, 32),
        knightBody: new THREE.CylinderGeometry(0.25, 0.35, 0.6, 16),
        knightHead: new THREE.BoxGeometry(0.3, 0.6, 0.2),
        bishopBody: new THREE.CylinderGeometry(0.15, 0.35, 1.0, 16),
        queenBody: new THREE.CylinderGeometry(0.2, 0.4, 1.4, 32),
        kingBody: new THREE.CylinderGeometry(0.25, 0.45, 1.6, 32),
        sphereSmall: new THREE.SphereGeometry(0.15),
        boxCross: new THREE.BoxGeometry(0.1, 0.4, 0.1),
        torus: new THREE.TorusGeometry(0.2, 0.05, 16, 32)
    };

    const MATERIALS = {
        white: new THREE.MeshStandardMaterial({color:0xeeeeff, roughness:0.2, metalness:0.5}),
        black: new THREE.MeshStandardMaterial({color:0x222222, roughness:0.3, metalness:0.8}),
        glowW: new THREE.MeshStandardMaterial({color:0x00e5ff, emissive:0x00e5ff, emissiveIntensity:2}),
        glowB: new THREE.MeshStandardMaterial({color:0xff0055, emissive:0xff0055, emissiveIntensity:2}),
        classicWhite: new THREE.MeshPhongMaterial({color: 0xdddddd, shininess: 30}),
        classicBlack: new THREE.MeshPhongMaterial({color: 0x111111, shininess: 30}),
        cursorGhost: new THREE.MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 0.6})
    };

    const firebaseConfig = {
        apiKey: "AIzaSyCxPppnUG864v3E2j1OzykzFmhLpsEJCSE",
        authDomain: "chess-1885a.firebaseapp.com",
        databaseURL: "https://chess-1885a-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "chess-1885a",
        storageBucket: "chess-1885a.firebasestorage.app",
        messagingSenderId: "824383572856",
        appId: "1:824383572856:web:7c663d6bf0f970f6acd68d",
        measurementId: "G-0EMJ4W2KLS"
    };

    let app, db, auth;
    let currentUser = null;
    let gameId = null;
    let playerColor = 'w';
    let isOnline = false;
    let isProcessing = false;
    let game = null;
    let selectedSquare = null; 
    let isRegistering = false;
    let userSettings = { 
        avatarSeed: "Bot", avatarImage: null, name: "Commander",
        pieceStyle: "neon", boardStyle: "neon"
    };
    let lastCursorUpdate = 0;
    let lastCameraUpdate = 0;
    let isGuestLoginIntent = false;

    function init3D(container, onClickCallback, onCameraUpdate) {
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xff9966, 0.0008);
        scene.background = new THREE.Color(0x331111);

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 6000);
        camera.position.set(0, 60, 100);

        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(CONFIG.pixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (!isMobile) {
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        
        const existingCanvas = document.querySelector('canvas');
        if (existingCanvas) existingCanvas.remove();
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2.05;
        controls.minDistance = 10; controls.maxDistance = 450;
        controls.target.set(0, BOARD_HEIGHT, 0);

        controls.addEventListener('change', () => {
            if(onCameraUpdate) onCameraUpdate(camera.position);
        });

        setupSunsetLighting();
        loadCustomModels();
        
        requestAnimationFrame(() => {
            createFloatingBoard();
            createProceduralTerrain();
            setTimeout(createVegetation, 50);
            setTimeout(createHighAltitudeClouds, 100);
        });

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        window.addEventListener('resize', onResize);
        window.addEventListener('touchstart', (e) => onTouchStart(e, onClickCallback), {passive: false});
        window.addEventListener('click', (e) => onMouseClick(e, onClickCallback));
        
        animate();
    }

    function setLoginMode(enabled) {
        isLoginRotating = enabled;
        if(controls) {
            controls.autoRotate = enabled;
            controls.autoRotateSpeed = 0.5;
        }
        if(!enabled) moveCamera({x: 0, y: 60, z: 100}, {x:0, y:BOARD_HEIGHT, z:0});
    }

    function updateOpponentGhost(pos) {
        if (!pos) return;
        if (!opponentCursorMesh) {
            const geo = new THREE.SphereGeometry(1.5, 16, 16);
            opponentCursorMesh = new THREE.Mesh(geo, MATERIALS.cursorGhost);
            scene.add(opponentCursorMesh);
            const light = new THREE.PointLight(0xffaa00, 1, 10);
            opponentCursorMesh.add(light);
        }

        if(window.TWEEN) {
            new TWEEN.Tween(opponentCursorMesh.position).to({x: pos.x, y: pos.y, z: pos.z}, 120).start();
        } else {
            opponentCursorMesh.position.set(pos.x, pos.y, pos.z);
        }
    }

    function updateTheme(settings) {
        if (settings.pieceStyle) currentSettings.pieceStyle = settings.pieceStyle;
        if (settings.boardStyle) currentSettings.boardStyle = settings.boardStyle;
        if (window.gameInstance) syncBoardVisuals(window.gameInstance);
    }

    function loadCustomModels() {
        const loader = new GLTFLoader();
        loader.load('./models/chess_set.glb', (gltf) => { customModels = gltf.scene; }, undefined, (error) => {});
    }

    function moveCamera(targetPos, lookAtPos) {
        if(window.TWEEN) {
            new TWEEN.Tween(camera.position).to(targetPos, 2000).easing(TWEEN.Easing.Cubic.Out).start();
        } else {
            camera.position.set(targetPos.x, targetPos.y, targetPos.z);
        }
        if(lookAtPos) controls.target.set(lookAtPos.x, lookAtPos.y, lookAtPos.z);
    }

    function syncBoardVisuals(chessInstance) {
        if(!window.gameInstance) window.gameInstance = chessInstance;
        for(let sq in piecesMap) scene.remove(piecesMap[sq]); 
        piecesMap = {};
        const b = chessInstance.board();
        for(let r=0; r<8; r++){
            for(let c=0; c<8; c++){
                const p = b[r][c];
                if(p){
                    const sq = String.fromCharCode(97+c)+(8-r);
                    const s = createOptimizedPiece(p.type, p.color);
                    s.position.set(c-3.5, BOARD_HEIGHT, r-3.5);
                    scene.add(s);
                    piecesMap[sq] = s;
                }
            }
        }
    }

    function highlightSquare(sq, moves) {
        clr();
        visSelectedSq = sq;
        if(tilesMap[sq]) {
            tilesMap[sq].material.emissive.setHex(0xffff00);
            tilesMap[sq].material.emissiveIntensity = 0.8;
        }
        moves.forEach(m => {
            if(tilesMap[m.to]) {
                tilesMap[m.to].material.emissive.setHex(m.captured ? 0xff3300 : 0x00aaff);
                tilesMap[m.to].material.emissiveIntensity = 0.5;
            }
        });
    }

    function clearHighlights() { clr(); visSelectedSq = null; }

    function animateMove(move, callback) {
        clr();
        const s = piecesMap[move.from];
        const targetTile = tilesMap[move.to];
        if(!s || !targetTile) { if(callback) callback(); return; }

        const ePos = targetTile.position.clone();
        if(move.captured && piecesMap[move.to]) scene.remove(piecesMap[move.to]);
        
        if(window.TWEEN) {
            new TWEEN.Tween(s.position).to(ePos, 200).easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => { 
                    if(move.promotion) scene.remove(s); 
                    if(callback) callback(); 
                }).start();
        } else {
            s.position.copy(ePos);
            if(callback) callback();
        }
    }

    function createOptimizedPiece(t, c) {
        if (customModels && currentSettings.pieceStyle === 'neon') { 
            const pieceName = getPieceName(t, c);
            const modelPiece = customModels.getObjectByName(pieceName);
            if (modelPiece) {
                const clone = modelPiece.clone();
                clone.scale.setScalar(2); 
                return clone;
            }
        }

        const g = new THREE.Group();

        if (currentSettings.pieceStyle === 'classic') {
            const mat = c === 'w' ? MATERIALS.classicWhite : MATERIALS.classicBlack;
            const base = new THREE.Mesh(GEOMETRIES.cylBase, mat);
            base.position.y = 0.1; if(!isMobile) base.castShadow = true;
            g.add(base);

            if(t === 'p') {
                const body = new THREE.Mesh(GEOMETRIES.pawnBody, mat); body.position.y = 0.5;
                const head = new THREE.Mesh(GEOMETRIES.pawnHead, mat); head.position.y = 0.95;
                g.add(body, head);
            } else if (t === 'k') {
                 const body = new THREE.Mesh(GEOMETRIES.kingBody, mat); body.position.y = 1.0;
                 const top = new THREE.Mesh(GEOMETRIES.boxCross, mat); top.position.y = 1.95; 
                 g.add(body, top);
            } else {
                const body = new THREE.Mesh(GEOMETRIES.rookBody, mat); body.position.y = 0.6;
                g.add(body);
            }
        } else {
            const mat = c === 'w' ? MATERIALS.white : MATERIALS.black;
            const glow = c === 'w' ? MATERIALS.glowW : MATERIALS.glowB;
            const base = new THREE.Mesh(GEOMETRIES.cylBase, mat);
            base.position.y = 0.1; if(!isMobile) base.castShadow = true;
            g.add(base);

            if(t === 'p') {
                const body = new THREE.Mesh(GEOMETRIES.pawnBody, mat); body.position.y = 0.5; if(!isMobile) body.castShadow = true;
                const head = new THREE.Mesh(GEOMETRIES.pawnHead, mat); head.position.y = 0.95; if(!isMobile) head.castShadow = true;
                g.add(body, head);
            } else if(t === 'r') {
                const body = new THREE.Mesh(GEOMETRIES.rookBody, mat); body.position.y = 0.6; if(!isMobile) body.castShadow = true;
                const head = new THREE.Mesh(GEOMETRIES.rookHead, mat); head.position.y = 1.1; if(!isMobile) head.castShadow = true;
                const top = new THREE.Mesh(GEOMETRIES.torus, glow); top.position.y = 1.25; top.rotation.x = Math.PI/2;
                g.add(body, head, top);
            } else if(t === 'n') {
                const body = new THREE.Mesh(GEOMETRIES.knightBody, mat); body.position.y = 0.5; if(!isMobile) body.castShadow = true;
                const head = new THREE.Mesh(GEOMETRIES.knightHead, mat); head.position.set(0, 1.0, 0.1); head.rotation.x = -Math.PI/6; if(!isMobile) head.castShadow = true;
                const eye = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.05), glow); eye.position.set(0, 1.1, -0.15); eye.rotation.x = -Math.PI/6;
                g.add(body, head, eye); if(c === 'b') g.rotation.y = Math.PI;
            } else if(t === 'b') {
                const body = new THREE.Mesh(GEOMETRIES.bishopBody, mat); body.position.y = 0.7; if(!isMobile) body.castShadow = true;
                const neck = new THREE.Mesh(GEOMETRIES.pawnBody, mat); neck.scale.set(0.5, 0.5, 0.5); neck.position.y = 1.35; 
                const top = new THREE.Mesh(GEOMETRIES.sphereSmall, glow); top.position.y = 1.7;
                g.add(body, neck, top);
            } else if(t === 'q') {
                const body = new THREE.Mesh(GEOMETRIES.queenBody, mat); body.position.y = 0.9; if(!isMobile) body.castShadow = true;
                const top = new THREE.Mesh(GEOMETRIES.sphereSmall, glow); top.position.y = 1.7; top.scale.setScalar(1.5);
                g.add(body, top);
            } else if(t === 'k') {
                const body = new THREE.Mesh(GEOMETRIES.kingBody, mat); body.position.y = 1.0; if(!isMobile) body.castShadow = true;
                const top = new THREE.Mesh(GEOMETRIES.boxCross, glow); top.position.y = 1.95;
                g.add(body, top);
            }
        }
        return g;
    }

    function getPieceName(type, color) {
        const names = { 'p': 'Pawn', 'r': 'Rook', 'n': 'Knight', 'b': 'Bishop', 'q': 'Queen', 'k': 'King' };
        const c = color === 'w' ? 'White' : 'Black';
        return `${c}_${names[type]}`;
    }

    function clr(){for(let s in tilesMap){tilesMap[s].material.emissive.setHex(0x000000);tilesMap[s].material.emissiveIntensity=0;}}
    
    // âœ¨ ä¿®æ­£ 2ï¼šç¢ºä¿é»æ“Šé¸å–®æŒ‰éˆ•æ™‚ï¼Œä¸æœƒè¢« 3D å ´æ™¯æ””æˆª âœ¨
    function onTouchStart(e, cb){
        if (e.target.closest('.auth-box') || e.target.closest('.hud-container') || e.target.closest('.side-panel') || e.target.id === 'mobile-menu-btn' || e.target.id === 'menu-backdrop' || e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'SELECT') return;
        if(e.touches.length > 1) return;
        e.preventDefault(); 
        mouse.x=(e.touches[0].clientX/window.innerWidth)*2-1;mouse.y=-(e.touches[0].clientY/window.innerHeight)*2+1;
        chk(cb);
    }
    function onMouseClick(e, cb){
        if (e.target.closest('.auth-box') || e.target.closest('.hud-container') || e.target.closest('.side-panel') || e.target.id === 'mobile-menu-btn' || e.target.id === 'menu-backdrop' || e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'SELECT') return;
        mouse.x=(e.clientX/window.innerWidth)*2-1;mouse.y=-(e.clientY/window.innerHeight)*2+1;
        chk(cb);
    }
    
    function chk(cb){
        raycaster.setFromCamera(mouse,camera);const i=raycaster.intersectObjects(Object.values(tilesMap));
        if(i.length>0 && cb) cb(i[0].object.userData.square);
    }
    function onResize(){camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);}
    function setupSunsetLighting(){
        const ambient=new THREE.AmbientLight(0xffccaa,0.75);scene.add(ambient);
        const sunLight=new THREE.DirectionalLight(0xff8800,3.2);
        sunLight.position.set(-300,100,-300);
        if(!isMobile) { sunLight.castShadow=true; sunLight.shadow.mapSize.set(CONFIG.shadowSize,CONFIG.shadowSize); const d=700;sunLight.shadow.camera.left=-d;sunLight.shadow.camera.right=d;sunLight.shadow.camera.top=d;sunLight.shadow.camera.bottom=-d; }
        scene.add(sunLight);
        const sky=new Sky();sky.scale.setScalar(450000);scene.add(sky);
        const uniforms=sky.material.uniforms;
        uniforms['turbidity'].value=10;uniforms['rayleigh'].value=3; uniforms['mieCoefficient'].value=0.005;uniforms['mieDirectionalG'].value=0.8; uniforms['sunPosition'].value.copy(sunLight.position);
    }
    function getTerrainHeight(x, z) {
        const dist = Math.sqrt(x*x + z*z);
        if (dist < 400) return -12 + Math.sin(x*0.004)*Math.cos(z*0.004)*2.0;
        const blend = smoothstep(400, 700, dist);
        let h = blend * 140; 
        h += Math.sin(x * 0.015) * Math.cos(z * 0.015) * 25; h += Math.sin(x * 0.03 + z * 0.02) * 10;
        return h - 12;
    }
    function smoothstep(min, max, value) { var x = Math.max(0, Math.min(1, (value - min) / (max - min))); return x * x * (3 - 2 * x); }
    function createProceduralTerrain(){
        const geo=new THREE.PlaneGeometry(3500,3500,isMobile?100:180,isMobile?100:180); geo.rotateX(-Math.PI/2); const pos=geo.attributes.position; const colors=[]; const c1=new THREE.Color(0x226622);const c2=new THREE.Color(0x665544);
        for(let i=0;i<pos.count;i++){ const h=getTerrainHeight(pos.getX(i),pos.getZ(i)); pos.setY(i,h); const b=smoothstep(-12,8,h); const c=c1.clone().lerp(c2,b); colors.push(c.r,c.g,c.b); }
        geo.setAttribute('color',new THREE.Float32BufferAttribute(colors,3)); geo.computeVertexNormals();
        const mat=new THREE.MeshStandardMaterial({vertexColors:true,roughness:0.9,metalness:0.1,flatShading:true}); const mesh=new THREE.Mesh(geo,mat); if(!isMobile) mesh.receiveShadow=true; scene.add(mesh);
    }
    function createVegetation(){
        const grp=new THREE.Group(); const lMat=new THREE.MeshStandardMaterial({color:0x1a3d1a,roughness:0.9,flatShading:true});const tMat=new THREE.MeshStandardMaterial({color:0x3d2817,roughness:1.0});const lGeo=new THREE.DodecahedronGeometry(4,0);const tGeo=new THREE.CylinderGeometry(0.7,1.0,6,6);tGeo.translate(0,3,0);for(let i=0;i<CONFIG.treeCount;i++){const a=Math.random()*Math.PI*2;const r=70+Math.random()*380;const x=Math.cos(a)*r;const z=Math.sin(a)*r;const h=getTerrainHeight(x,z);const tr=new THREE.Group();const t=new THREE.Mesh(tGeo,tMat);if(!isMobile) t.castShadow=true;tr.add(t);for(let j=0;j<3;j++){const l=new THREE.Mesh(lGeo,lMat);l.position.set((Math.random()-0.5)*5,5.5+Math.random()*3.5,(Math.random()-0.5)*5);l.scale.setScalar(0.8+Math.random()*0.4);if(!isMobile) l.castShadow=true;tr.add(l);}tr.position.set(x,h,z);tr.scale.setScalar(0.9+Math.random()*0.6);grp.add(tr);}scene.add(grp);
        const bGeo=new THREE.PlaneGeometry(0.3,1.5);bGeo.translate(0,0.75,0); grassMat=new THREE.MeshStandardMaterial({color:0x226622,side:THREE.DoubleSide});
        grassMat.onBeforeCompile=s=>{s.uniforms.time={value:0};s.vertexShader=`uniform float time;\n`+s.vertexShader;s.vertexShader=s.vertexShader.replace(`#include <begin_vertex>`,`vec3 transformed=vec3(position);float w=sin(time*1.5+position.x*0.5)*0.2*position.y;transformed.x+=w;#include <begin_vertex>`);grassMat.userData.shader=s;};
        const iG=new THREE.InstancedMesh(bGeo,grassMat,CONFIG.grassCount); const dummy=new THREE.Object3D();let c=0;
        for(let i=0;i<100000;i++){ if(c>=CONFIG.grassCount)break; const r=Math.random()*420;const a=Math.random()*Math.PI*2;const x=Math.cos(a)*r;const z=Math.sin(a)*r;const h=getTerrainHeight(x,z); if(h<-8){dummy.position.set(x,h,z);dummy.rotation.y=Math.random()*Math.PI;dummy.scale.setScalar(0.7+Math.random()*0.6);dummy.updateMatrix();iG.setMatrixAt(c++,dummy.matrix);} }
        if(!isMobile) iG.receiveShadow=true; scene.add(iG);
    }
    function createHighAltitudeClouds(){
        const cv=document.createElement('canvas');cv.width=128;cv.height=128; const cx=cv.getContext('2d'),g=cx.createRadialGradient(64,64,0,64,64,64);g.addColorStop(0,'rgba(255,180,120,0.5)');g.addColorStop(1,'rgba(0,0,0,0)');cx.fillStyle=g;cx.fillRect(0,0,128,128);
        const mat=new THREE.SpriteMaterial({map:new THREE.CanvasTexture(cv),transparent:true,blending:THREE.AdditiveBlending,depthWrite:false}); const gp=new THREE.Group();
        for(let i=0;i<(isMobile?25:45);i++){ const cl=new THREE.Group(); for(let j=0;j<15;j++){const p=new THREE.Sprite(mat);p.position.set((Math.random()-0.5)*50,(Math.random()-0.5)*20,(Math.random()-0.5)*50);p.scale.setScalar(40+Math.random()*40);cl.add(p);} cl.position.set((Math.random()-0.5)*3200,250+Math.random()*150,(Math.random()-0.5)*3200);gp.add(cl);cloudParticles.push(cl);}scene.add(gp);
    }
    function createFloatingBoard(){
        const g=new THREE.TorusGeometry(8,0.3,16,32);const m=new THREE.MeshBasicMaterial({color:0xffaa00});const r=new THREE.Mesh(g,m);r.rotation.x=Math.PI/2;r.position.y=BOARD_HEIGHT-3;scene.add(r);
        const b=new THREE.Mesh(new THREE.BoxGeometry(9,0.5,9),new THREE.MeshStandardMaterial({color:0x221111,roughness:0.5}));b.position.y=BOARD_HEIGHT-0.25;if(!isMobile) b.receiveShadow=true;scene.add(b);
        for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const n=String.fromCharCode(97+c)+(r+1),w=(r+c)%2!==0; const t=new THREE.Mesh(new THREE.BoxGeometry(1,0.2,1),new THREE.MeshStandardMaterial({color:w?0xffddbb:0x443333,roughness:0.2,metalness:0.3})); t.position.set(c-3.5,BOARD_HEIGHT,3.5-r);t.userData={square:n,isTile:true};if(!isMobile) {t.receiveShadow=true;t.castShadow=true;}scene.add(t);tilesMap[n]=t; }
    }
    function animate(){
        requestAnimationFrame(animate); const t=clock.getElapsedTime(); if(window.TWEEN) window.TWEEN.update(); controls.update();
        if(grassMat&&grassMat.userData.shader)grassMat.userData.shader.uniforms.time.value=t; cloudParticles.forEach(c=>{c.rotation.y+=0.0003;}); renderer.render(scene,camera);
    }

    function initGame() {
        console.log("Game Logic Initializing...");
        if (window.Chess) { game = new window.Chess(); } 
        else { alert("éŒ¯èª¤ï¼šChess.js æœªè¼‰å…¥"); return; }

        try {
            app = initializeApp(firebaseConfig);
            db = getDatabase(app);
            auth = getAuth(app);
        } catch(e) { console.error("Firebase Init Error:", e); }

        init3D(null, handleSquareClick, handleCameraUpdate);
        setLoginMode(true);

        setTimeout(setupUIListeners, 500);
        
        onAuthStateChanged(auth, (user) => {
            const loadingEl = document.getElementById('loading');
            if(loadingEl) loadingEl.style.display = 'none';
            
            if (user) {
                if (user.isAnonymous && !isGuestLoginIntent) {
                    signOut(auth); return;
                }
                currentUser = user;
                document.getElementById('auth-modal').style.display = 'none';
                document.getElementById('ui').style.display = 'block';
                setLoginMode(false);
                checkAndCreateUserProfile(user);
            } else {
                currentUser = null;
                document.getElementById('auth-modal').style.display = 'flex';
                document.getElementById('ui').style.display = 'none';
                setLoginMode(true);
                resetAuthForm();
                isGuestLoginIntent = false;
            }
        });

        setTimeout(() => { if(game) syncBoardVisuals(game); }, 100);
    }

    function setupUIListeners() {
        const bind = (id, fn) => {
            const el = document.getElementById(id);
            if(el) { el.onclick = fn; } 
        };

        bind('btn-create', createRoom);
        bind('btn-join', joinRoom);
        bind('btn-leave', leaveRoom);
        bind('auth-action-btn', handleLogin);
        
        const guestBtn = document.getElementById('guest-btn');
        if(guestBtn) {
            guestBtn.onclick = () => {
                isGuestLoginIntent = true;
                signInAnonymously(auth).catch((error) => {
                    isGuestLoginIntent = false; handleAuthError(error);
                });
            };
        }

        bind('btn-logout', handleLogout); 
        bind('forgot-pw', handleForgotPassword);
        bind('btn-custom', () => {
            document.getElementById('custom-panel').classList.add('active');
            if(currentUser && currentUser.isAnonymous) {
                document.getElementById('guest-avatar-controls').style.display = 'block';
            } else { document.getElementById('guest-avatar-controls').style.display = 'none'; }
        });

        bind('btn-save-custom', saveUserSettings);
        bind('btn-random-avatar', randomizeAvatar);

        const fileInput = document.getElementById('avatar-upload');
        if(fileInput) fileInput.addEventListener('change', handleAvatarFileSelect);
        document.getElementById('avatar-seed').oninput = (e) => updateAvatarPreview(e.target.value, null);
    }

    function handleCameraUpdate(camData) {
        if (!isOnline || !gameId || !currentUser) return;
        const now = Date.now();
        if (now - lastCameraUpdate > 200) {
            update(ref(db, `games/${gameId}/${playerColor}/camera`), { x: camData.x, y: camData.y, z: camData.z });
            lastCameraUpdate = now;
        }
    }

    function setupGameListeners() {
        onValue(ref(db, 'games/' + gameId), (snapshot) => {
            const data = snapshot.val();
            if (!data) return;
            
            if (data.status === 'playing' && !data.winner && document.getElementById('turn-txt').innerText.includes("ç­‰å¾…")) {
                if (data.black) {
                    const oppName = playerColor === 'w' ? data.black.name : data.white.name;
                    document.getElementById('opponent-info').innerText = `VS: ${oppName}`;
                    document.getElementById('room-display').innerText = `æˆ¿é–“è™Ÿï¼š${gameId} (å°æˆ°ä¸­)`;
                    if(playerColor === 'w') alert(`å°æ‰‹ ${data.black.name} å·²åŠ å…¥ï¼`);
                    updateStatusHUD();
                }
            }
            if (data.fen !== game.fen()) {
                game.load(data.fen);
                syncBoardVisuals(game); updateStatusHUD();
                if (game.turn() === playerColor) isProcessing = false;
            }
            if (data.winner) handleGameOver(data.winner);
        });

        const opponentColor = playerColor === 'w' ? 'b' : 'w';
        onValue(ref(db, `games/${gameId}/${opponentColor}/camera`), (snapshot) => {
            const pos = snapshot.val(); if (pos) updateOpponentGhost(pos);
        });
    }

    function handleLogout() {
        if (!currentUser) return;
        if (currentUser.isAnonymous) {
            const confirmLogout = confirm("è¨ªå®¢ç™»å‡ºå¾Œï¼Œæ‚¨çš„æˆ°ç¸¾å°‡æœƒè¢«åˆªé™¤ã€‚ç¢ºå®šè¦ç™»å‡ºå—ï¼Ÿ");
            if (!confirmLogout) return;
            remove(ref(db, 'users/' + currentUser.uid)).then(() => signOut(auth)).catch(() => signOut(auth));
        } else { signOut(auth); }
    }

    function leaveRoom() {
        if (!gameId) return;
        const confirmLeave = confirm("ç¢ºå®šè¦é€€å‡ºæˆ¿é–“å—ï¼Ÿ");
        if (!confirmLeave) return;

        off(ref(db, 'games/' + gameId)); off(ref(db, `games/${gameId}/w/camera`)); off(ref(db, `games/${gameId}/b/camera`));
        gameId = null; isOnline = false; game.reset();
        syncBoardVisuals(game); moveCamera({x: 0, y: 60, z: 100}); updateOpponentGhost(null); toggleLobbyUI(false);
    }

    function toggleLobbyUI(isPlaying) {
        const lobbyBtns = document.getElementById('lobby-buttons'); const leaveBtn = document.getElementById('btn-leave');
        if (isPlaying) { lobbyBtns.style.display = 'none'; leaveBtn.style.display = 'block';
        } else { lobbyBtns.style.display = 'block'; leaveBtn.style.display = 'none'; document.getElementById('room-display').innerText = 'ç‹€æ…‹ï¼šé–’ç½®ä¸­'; document.getElementById('room-display').style.color = '#fff'; document.getElementById('opponent-info').innerText = 'å°æ‰‹: ---'; }
    }

    function createRoom() {
        if (!currentUser) { alert("è«‹å…ˆç™»å…¥"); return; }
        game.reset(); syncBoardVisuals(game); 
        gameId = Math.floor(1000 + Math.random() * 9000).toString();
        
        document.getElementById('room-display').innerHTML = `æˆ¿é–“è™Ÿç¢¼ï¼š<span style="color:#00e5ff; font-size:16px;">${gameId}</span><br>ç­‰å¾…å°æ‰‹åŠ å…¥...`;
        document.getElementById('opponent-info').innerText = "ç­‰å¾…å°æ‰‹...";
        toggleLobbyUI(true);
        
        get(ref(db, 'users/' + currentUser.uid)).then(snap => {
            const userData = snap.val() || { name: "Player", elo: 0 };
            set(ref(db, 'games/' + gameId), { fen: game.fen(), turn: 'w', white: { uid: currentUser.uid, elo: userData.elo, name: userData.name }, black: null, status: 'waiting' }).then(() => {
                playerColor = 'w'; isOnline = true; setupGameListeners(); moveCamera({x: 0, y: 60, z: 100}); alert(`æˆ¿é–“å·²å»ºç«‹ï¼è™Ÿç¢¼ï¼š${gameId}`);
            }).catch(err => { alert("ç¶²è·¯éŒ¯èª¤ï¼Œç„¡æ³•å»ºç«‹æˆ¿é–“"); leaveRoom(); });
        });
    }

    function joinRoom() {
        const id = prompt('è«‹è¼¸å…¥æˆ¿é–“è™Ÿç¢¼:'); if(!id) return;
        get(ref(db, 'games/' + id)).then((snapshot) => {
            if (snapshot.exists()) {
                const gameData = snapshot.val();
                if(gameData.status !== 'waiting') { alert("æˆ¿é–“å·²æ»¿æˆ–éŠæˆ²å·²çµæŸ"); return; }
                gameId = id; game.reset(); syncBoardVisuals(game); toggleLobbyUI(true);
                const myInfo = { uid: currentUser.uid, elo: userSettings.elo || 0, name: userSettings.name || "Player" };
                update(ref(db, 'games/' + gameId), { black: myInfo, status: 'playing' }).then(() => {
                    playerColor = 'b'; isOnline = true; setupGameListeners();
                    document.getElementById('room-display').innerText = `æˆ¿é–“è™Ÿï¼š${gameId} (å°æˆ°ä¸­)`;
                    document.getElementById('opponent-info').innerText = `VS: ${gameData.white.name}`;
                    moveCamera({x: 0, y: 60, z: -100}); game.load(gameData.fen); syncBoardVisuals(game); updateStatusHUD();
                });
            } else { alert("æˆ¿é–“ä¸å­˜åœ¨"); }
        });
    }

    function previewStyle(type, value) { const tempSettings = {}; if (type === 'piece') tempSettings.pieceStyle = value; if (type === 'board') tempSettings.boardStyle = value; updateTheme(tempSettings); }
    function triggerAvatarUpload() { if (currentUser && !currentUser.isAnonymous) { document.getElementById('avatar-upload').click(); } else { alert("è¨ªå®¢è«‹ä½¿ç”¨éš¨æ©Ÿä»£ç¢¼ï¼Œæˆ–è¨»å†Šä»¥è§£é–ä¸Šå‚³åŠŸèƒ½ã€‚"); } }
    function handleAvatarFileSelect(e) { const file = e.target.files[0]; if (!file) return; if (file.size > 1024 * 1024) { alert("åœ–ç‰‡è«‹å°æ–¼ 1MB"); return; } const reader = new FileReader(); reader.onload = function(evt) { const base64 = evt.target.result; updateAvatarPreview(null, base64); userSettings.tempAvatarImage = base64; }; reader.readAsDataURL(file); }
    function randomizeAvatar() { const randomSeed = Math.random().toString(36).substring(7); document.getElementById('avatar-seed').value = randomSeed; updateAvatarPreview(randomSeed, null); }
    function updateAvatarPreview(seed, base64) { const imgEl = document.getElementById('my-avatar'); if (base64) { imgEl.src = base64; } else { const s = seed || userSettings.avatarSeed; imgEl.src = `https://api.dicebear.com/7.x/bottts/svg?seed=${s}`; } }
    function saveUserSettings() {
        if (!currentUser) return;
        const newName = document.getElementById('edit-name').value.trim();
        const newSettings = { name: newName || userSettings.name, pieceStyle: document.getElementById('selected-piece-style').value, boardStyle: document.getElementById('selected-board-style').value };
        if (currentUser.isAnonymous) { newSettings.avatarSeed = document.getElementById('avatar-seed').value; } else if (userSettings.tempAvatarImage) { newSettings.avatarImage = userSettings.tempAvatarImage; }
        update(ref(db, 'users/' + currentUser.uid), newSettings).then(() => {
            alert("è¨­å®šå·²ä¿å­˜ï¼"); userSettings = { ...userSettings, ...newSettings }; delete userSettings.tempAvatarImage; loadUserProfile(); document.getElementById('custom-panel').classList.remove('active');
        });
    }

    function checkAndCreateUserProfile(user) {
        const userRef = ref(db, 'users/' + user.uid);
        get(userRef).then((snapshot) => {
            if (!snapshot.exists()) {
                const nickEl = document.getElementById('nickname'); const inputName = nickEl ? nickEl.value.trim() : ""; const name = inputName || (user.isAnonymous ? `è¨ªå®¢_${user.uid.substring(0,4)}` : user.email.split('@')[0]);
                set(userRef, { name: name, email: user.email || "guest", elo: 0, wins: 0, losses: 0 }).then(loadUserProfile);
            } else { loadUserProfile(); }
        });
    }

    function loadUserProfile() {
        if (!currentUser) return;
        onValue(ref(db, 'users/' + currentUser.uid), (snapshot) => {
            const data = snapshot.val();
            if (data) {
                userSettings = { ...userSettings, ...data }; document.getElementById('user-name').innerText = data.name; document.getElementById('edit-name').value = data.name; document.getElementById('user-elo').innerText = data.elo;
                const seed = data.avatarSeed || data.name; const avatarUrl = data.avatarImage ? data.avatarImage : `https://api.dicebear.com/7.x/bottts/svg?seed=${seed}`;
                document.getElementById('hud-avatar').src = avatarUrl; document.getElementById('my-avatar').src = avatarUrl; if(!data.avatarImage) document.getElementById('avatar-seed').value = seed;
                updateRankBadge(data.elo); if(data.pieceStyle) document.getElementById('selected-piece-style').value = data.pieceStyle; if(data.boardStyle) document.getElementById('selected-board-style').value = data.boardStyle; updateTheme(userSettings);
            }
        });
    }

    function updateRankBadge(elo) {
        const badge = document.getElementById('user-rank'); badge.className = 'rank-badge';
        if (elo < 200) { badge.innerText = "æ–°æ‰‹ NOVICE"; badge.classList.add('rank-bronze'); }
        else if (elo < 500) { badge.innerText = "éŠ…ç‰Œ BRONZE"; badge.classList.add('rank-bronze'); }
        else if (elo < 1000) { badge.innerText = "éŠ€ç‰Œ SILVER"; badge.classList.add('rank-silver'); }
        else if (elo < 1500) { badge.innerText = "é‡‘ç‰Œ GOLD"; badge.classList.add('rank-gold'); }
        else if (elo < 2000) { badge.innerText = "é‘½çŸ³ DIAMOND"; badge.classList.add('rank-diamond'); }
        else { badge.innerText = "éœ“è™¹å®—å¸«"; badge.classList.add('rank-master'); }
    }

    function handleSquareClick(sq) {
        if(isProcessing) return; if(isOnline && game.turn() !== playerColor) return;
        const p = game.get(sq);
        if(!selectedSquare) {
            if(p && p.color === game.turn()) {
                if(!isOnline || (isOnline && p.color === playerColor)) {
                    selectedSquare = sq; const validMoves = game.moves({square: sq, verbose: true}); highlightSquare(sq, validMoves);
                }
            }
        } else {
            if(p && p.color === game.turn()) {
                selectedSquare = sq; const validMoves = game.moves({square: sq, verbose: true}); highlightSquare(sq, validMoves); return;
            }
            const move = game.move({from: selectedSquare, to: sq, promotion: 'q'});
            if(move) {
                isProcessing = true;
                animateMove(move, () => {
                    syncBoardVisuals(game); updateStatusHUD();
                    if(isOnline) sendMove(move); else { if(game.turn() === 'b') setTimeout(makeRandomAI, 500); else isProcessing = false; }
                });
                selectedSquare = null;
            } else { selectedSquare = null; clearHighlights(); }
        }
    }

    function resetAuthForm() { isRegistering = false; document.getElementById('nickname-container').style.display = 'none'; document.getElementById('auth-action-btn').innerText = "é€²å…¥ä¸–ç•Œ"; document.getElementById('auth-error').innerText = ""; }

    async function handleLogin() {
        const emailEl = document.getElementById('email'); const passEl = document.getElementById('password'); const errorMsg = document.getElementById('auth-error');
        if(!emailEl || !passEl) return;
        const email = emailEl.value.trim(); const password = passEl.value.trim();
        if(!email || !password) { errorMsg.innerText = "è«‹è¼¸å…¥å¸³è™Ÿå¯†ç¢¼"; return; }
        if(!email.includes('@')) { errorMsg.innerText = "Email æ ¼å¼ä¸æ­£ç¢º"; return; }

        if (isRegistering) {
            const nickname = document.getElementById('nickname').value.trim(); if(!nickname) { errorMsg.innerText = "è«‹è¼¸å…¥æ‚¨çš„æš±ç¨±"; return; }
            errorMsg.innerText = "è¨»å†Šä¸­..."; try { await createUserWithEmailAndPassword(auth, email, password); } catch (error) { handleAuthError(error); } return;
        }

        errorMsg.innerText = "é©—è­‰èº«åˆ†ä¸­...";
        try {
            await signInWithEmailAndPassword(auth, email, password);
        } catch (error) {
            if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-credential' || error.code === 'auth/invalid-login-credentials') {
                isRegistering = true; document.getElementById('nickname-container').style.display = 'block'; document.getElementById('auth-action-btn').innerText = "ç¢ºèªè¨»å†Š"; errorMsg.innerText = "æ­¡è¿æ–°æŒ‡æ®å®˜ï¼Œè«‹è¨­å®šæš±ç¨±ã€‚"; errorMsg.style.color = "#00ff00"; 
            } else { handleAuthError(error); }
        }
    }

    function handleAuthError(error) {
        const errorMsg = document.getElementById('auth-error'); errorMsg.style.color = "#ff0055"; let msg = error.message;
        if(msg.includes("weak-password")) msg = "å¯†ç¢¼å¤ªå¼±"; if(msg.includes("email-already-in-use")) msg = "æ­¤ä¿¡ç®±å·²è¢«è¨»å†Š";
        errorMsg.innerText = msg; console.error("Auth Error:", error);
    }

    async function handleForgotPassword() {
        const email = document.getElementById('email').value.trim(); const errorMsg = document.getElementById('auth-error');
        if(!email || !email.includes('@')) { errorMsg.innerText = "è«‹å…ˆè¼¸å…¥ Email"; return; }
        try { await sendPasswordResetEmail(auth, email); alert(`å¯†ç¢¼é‡è¨­ä¿¡å·²ç™¼é€è‡³ ${email}`); } catch (error) { errorMsg.innerText = "ç™¼é€å¤±æ•—ï¼š" + error.message; }
    }

    function updateStatusHUD(){
        const t = document.getElementById('turn-txt'); const turn = game.turn();
        if(isOnline){ t.innerText = turn==='w' ? "ç™½æ–¹å›åˆ" : "é»‘æ–¹å›åˆ"; t.style.color = turn==='w' ? "#00e5ff" : "#ff0055";
        } else { t.innerText = turn==='w' ? "è—æ–¹å›åˆ" : "é›»è…¦å›åˆ"; t.style.color = turn==='w' ? "#00e5ff" : "#ff0055"; }
    }

    function handleGameOver(winnerColor) {
        isProcessing = true; let msg = winnerColor === playerColor ? "å‹åˆ©ï¼" : "æˆ°æ•—..."; alert(msg);
        const t = document.getElementById('turn-txt'); t.innerText = winnerColor === 'w' ? "ç™½æ–¹å‹åˆ©" : "é»‘æ–¹å‹åˆ©"; t.style.color = "#ffff00";
    }

    function calculateELO(winnerColor) {
        get(ref(db, 'games/' + gameId)).then(snap => {
            const data = snap.val(); if(data.calculated) return; 
            if(playerColor === 'w') {
                const K = 32; const expectW = 1 / (1 + Math.pow(10, (data.black.elo - data.white.elo) / 400)); const expectB = 1 / (1 + Math.pow(10, (data.white.elo - data.black.elo) / 400));
                const newWElo = Math.round(data.white.elo + K * ((winnerColor === 'w' ? 1 : 0) - expectW)); const newBElo = Math.round(data.black.elo + K * ((winnerColor === 'b' ? 1 : 0) - expectB));
                update(ref(db, 'users/' + data.white.uid), { elo: newWElo }); update(ref(db, 'users/' + data.black.uid), { elo: newBElo }); update(ref(db, 'games/' + gameId), { calculated: true });
            }
        });
    }

    function sendMove(move) {
        if (!isOnline) return;
        const nextFen = game.fen(); let updateData = { fen: nextFen, turn: game.turn(), lastMove: move };
        if (game.in_checkmate()) { const winnerColor = game.turn() === 'w' ? 'b' : 'w'; updateData.winner = winnerColor; updateData.status = 'finished'; calculateELO(winnerColor); }
        update(ref(db, 'games/' + gameId), updateData); isProcessing = false;
    }

    function makeRandomAI(){
        const ms = game.moves(); if(ms.length === 0) return; const m = ms[Math.floor(Math.random() * ms.length)]; game.move(m);
        animateMove(game.history({verbose:true}).pop(), () => { syncBoardVisuals(game); updateStatusHUD(); isProcessing = false; });
    }

    window.triggerAvatarUpload = triggerAvatarUpload; 
    window.previewSkin = function(type, value, element) {
        if(element.classList.contains('locked')) return; const grid = document.getElementById(`${type}-skin-grid`); const items = grid.getElementsByClassName('skin-item');
        for(let item of items) item.classList.remove('selected'); element.classList.add('selected'); document.getElementById(`selected-${type}-style`).value = value; previewStyle(type, value);
    }
    window.onload = () => { initGame(); };
    window.toggleMenu = function() {
        const panel = document.getElementById('menu-panel'); panel.classList.toggle('mobile-visible');
        const backdrop = document.getElementById('menu-backdrop'); if(panel.classList.contains('mobile-visible')) { backdrop.classList.add('active'); } else { backdrop.classList.remove('active'); }
    }
    window.closeAllMenus = function() {
        document.getElementById('custom-panel').classList.remove('active');
        if(window.innerWidth <= 600) { document.getElementById('menu-backdrop').classList.remove('active'); document.getElementById('menu-panel').classList.remove('mobile-visible'); }
    }
</script>
</body>
</html>
