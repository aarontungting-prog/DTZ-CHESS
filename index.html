<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é€£ç·šç‰ˆå½ˆå¼“è¶³çƒ</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>
    <div id="ui-container">
        <h1>âš½ å½ˆå¼“è¶³çƒå°æˆ°</h1>
        <div id="menu">
            <button id="create-btn">å‰µå»ºæˆ¿é–“ (Create Room)</button>
            <br><br>
            <input type="text" id="room-input" placeholder="è¼¸å…¥æˆ¿è™Ÿ (Room ID)">
            <button id="join-btn">åŠ å…¥æˆ¿é–“ (Join Room)</button>
        </div>
        <div id="status" style="display:none;">
            <h2 id="room-display">æˆ¿è™Ÿï¼š</h2>
            <h2 id="score-display">ğŸ”´ ç´…éšŠ 0 - 0 è—éšŠ ğŸ”µ</h2>
            <p id="turn-display">ç­‰å¾…å°æ‰‹åŠ å…¥...</p>
        </div>
    </div>

    <div id="game-container" style="display:none;">
        <canvas id="game-canvas"></canvas>
    </div>

    <script type="module" src="app.js"></script>
</body>
</html>
body {
    margin: 0;
    padding: 0;
    background-color: #2c3e50;
    color: white;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
}

#ui-container {
    text-align: center;
    margin-top: 20px;
    margin-bottom: 10px;
}

button {
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    background-color: #e74c3c;
    color: white;
    border: none;
    border-radius: 5px;
}

button:hover {
    background-color: #c0392b;
}

input {
    padding: 10px;
    font-size: 16px;
}

#game-container {
    /* çƒå ´é‚Šæ¡†è¨­å®š */
    border: 5px solid white;
    background-color: #27ae60; /* ç¶“å…¸è¶³çƒå ´ç¶ è‰² */
    border-radius: 10px;
    position: relative;
    overflow: hidden;
}

canvas {
    display: block;
}
// Import the functions you need from the SDKs you need
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-app.js";
import { getDatabase, ref, set, onValue, update, get } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-database.js";

// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyCnONA7vSsBwOcui-bVBmmZfD_TOVZmck0",
  authDomain: "airplane-game-68f8f.firebaseapp.com",
  projectId: "airplane-game-68f8f",
  storageBucket: "airplane-game-68f8f.firebasestorage.app",
  messagingSenderId: "215248477446",
  appId: "1:215248477446:web:f1d9dbb69b759118125287",
  measurementId: "G-GKWZMFT66H",
  // åŠ ä¸Š databaseURL ä»¥å•Ÿç”¨ Realtime Database (å³æ™‚è³‡æ–™åº«)
  databaseURL: "https://airplane-game-68f8f-default-rtdb.firebaseio.com/" 
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

// === éŠæˆ²ç‹€æ…‹ (Game State) ===
let currentRoom = null;
let playerColor = null; // 'red' æˆ– 'blue'
let isMyTurn = false;
let scores = { red: 0, blue: 0 };

// === UI å…ƒç´  ===
const menuDiv = document.getElementById('menu');
const statusDiv = document.getElementById('status');
const gameContainer = document.getElementById('game-container');
const roomDisplay = document.getElementById('room-display');
const scoreDisplay = document.getElementById('score-display');
const turnDisplay = document.getElementById('turn-display');
const roomInput = document.getElementById('room-input');

// === Matter.js è¨­å®š ===
const Engine = Matter.Engine,
      Render = Matter.Render,
      Runner = Matter.Runner,
      Bodies = Matter.Bodies,
      Composite = Matter.Composite,
      Events = Matter.Events,
      Mouse = Matter.Mouse,
      MouseConstraint = Matter.MouseConstraint;

let engine, render, runner;
let ball;
let players = [];
let slingshots = []; // ç”¨ä¾†å°‡çƒå“¡å›ºå®šåœ¨åŸä½çš„ç´„æŸ (Constraint)

const width = 400;
const height = 600;

function initPhysics() {
    engine = Engine.create();
    // é—œé–‰é‡åŠ› (Gravity) å› ç‚ºé€™æ˜¯å¾ä¸Šå¾€ä¸‹çœ‹çš„è¦–è§’ (Top-down view)
    engine.world.gravity.y = 0; 
    
    render = Render.create({
        canvas: document.getElementById('game-canvas'),
        engine: engine,
        options: {
            width: width,
            height: height,
            wireframes: false, // é—œé–‰ç·šæ¡†æ¨¡å¼ï¼Œé¡¯ç¤ºé¡è‰²
            background: 'transparent'
        }
    });

    // å»ºç«‹é‚Šç•Œ (Walls)
    const walls = [
        Bodies.rectangle(width/2, 0, width, 20, { isStatic: true, render: { fillStyle: 'white' } }), // ä¸Š
        Bodies.rectangle(width/2, height, width, 20, { isStatic: true, render: { fillStyle: 'white' } }), // ä¸‹
        Bodies.rectangle(0, height/2, 20, height, { isStatic: true, render: { fillStyle: 'white' } }), // å·¦
        Bodies.rectangle(width, height/2, 20, height, { isStatic: true, render: { fillStyle: 'white' } }) // å³
    ];
    
    // ä¸­ç·š (Midline) - è¦–è¦ºç”¨ï¼Œä¸æœƒç¢°æ’
    const midline = Bodies.rectangle(width/2, height/2, width, 5, { 
        isStatic: true, 
        isSensor: true, // è¨­ç‚ºæ„Ÿæ¸¬å™¨ (Sensor) ä»£è¡¨çƒå¯ä»¥ç©¿é€éå»
        render: { fillStyle: 'white' } 
    });

    Composite.add(engine.world, [...walls, midline]);

    // åˆå§‹åŒ–çƒèˆ‡çƒå“¡
    resetPositions();

    Render.run(render);
    runner = Runner.create();
    Runner.run(runner, engine);

    setupMouseInteraction();
}

function resetPositions() {
    // ç§»é™¤èˆŠçš„çƒå“¡èˆ‡çƒ
    if(ball) Composite.remove(engine.world, ball);
    players.forEach(p => Composite.remove(engine.world, p));
    slingshots.forEach(s => Composite.remove(engine.world, s));
    players = [];
    slingshots = [];

    // å»ºç«‹è¶³çƒ (Ball)
    ball = Bodies.circle(width/2, height/2, 12, { 
        restitution: 0.9, // å½ˆæ€§ (Restitution)
        frictionAir: 0.02, // ç©ºæ°£é˜»åŠ› (Air friction) ä½¿çƒæ…¢æ…¢åœä¸‹
        render: { fillStyle: 'white' } 
    });
    Composite.add(engine.world, ball);

    // çƒå“¡é™£å‹åº§æ¨™ (2-3-2)
    const bluePositions = [
        {x: 150, y: 100}, {x: 250, y: 100}, // å¾Œè¡›
        {x: 100, y: 180}, {x: 200, y: 180}, {x: 300, y: 180}, // ä¸­å ´
        {x: 150, y: 260}, {x: 250, y: 260} // å‰é‹’
    ];
    
    const redPositions = [
        {x: 150, y: 500}, {x: 250, y: 500}, // å¾Œè¡›
        {x: 100, y: 420}, {x: 200, y: 420}, {x: 300, y: 420}, // ä¸­å ´
        {x: 150, y: 340}, {x: 250, y: 340} // å‰é‹’
    ];

    function createTeam(positions, color) {
        positions.forEach(pos => {
            let player = Bodies.circle(pos.x, pos.y, 18, {
                restitution: 0.6,
                frictionAir: 0.05,
                render: { fillStyle: color === 'blue' ? '#3498db' : '#e74c3c' },
                team: color
            });
            
            // å½ˆç°§ç´„æŸ (Constraint)ï¼ŒæŠŠçƒå“¡ç¶åœ¨åŸä½
            let tether = Matter.Constraint.create({
                pointA: { x: pos.x, y: pos.y },
                bodyB: player,
                stiffness: 0.05, // ç¡¬åº¦ (Stiffness)
                render: { visible: false }
            });

            players.push(player);
            slingshots.push(tether);
            Composite.add(engine.world, [player, tether]);
        });
    }

    createTeam(bluePositions, 'blue');
    createTeam(redPositions, 'red');
}

// è™•ç†æ»‘é¼ æ‹‰å‹•èˆ‡ç™¼å°„
function setupMouseInteraction() {
    const mouse = Mouse.create(render.canvas);
    const mouseConstraint = MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: { stiffness: 0.2, render: { visible: false } }
    });
    Composite.add(engine.world, mouseConstraint);

    // åªèƒ½åœ¨è‡ªå·±çš„å›åˆæ‹‰å‹•è‡ªå·±çš„çƒå“¡
    Events.on(mouseConstraint, 'startdrag', function(event) {
        const body = event.body;
        if (!isMyTurn || body.team !== playerColor || body === ball) {
            mouseConstraint.body = null; // é˜»æ­¢æ‹–æ›³
        }
    });

    Events.on(mouseConstraint, 'enddrag', function(event) {
        if (!isMyTurn) return;
        const body = event.body;
        
        // å–å¾—å½ˆæ€§ç¹©çš„éŒ¨é» (Anchor point)
        const tether = slingshots.find(s => s.bodyB === body);
        if (tether) {
            // è¨ˆç®—æ‹‰å‹•çš„å‘é‡ (Vector) ä¸¦å°‡æ“ä½œå‚³é€çµ¦ Firebase
            const dx = body.position.x - tether.pointA.x;
            const dy = body.position.y - tether.pointA.y;
            
            // å°‡æ“ä½œç™¼é€åˆ°è³‡æ–™åº«ï¼ŒåŒæ­¥çµ¦å°æ‰‹
            const actionRef = ref(db, `rooms/${currentRoom}/action`);
            set(actionRef, {
                playerId: players.indexOf(body),
                forceX: dx * -0.05, // å¾€åæ–¹å‘æ–½åŠ›
                forceY: dy * -0.05,
                timestamp: Date.now()
            });

            // æ›å°æ‰‹å›åˆ
            update(ref(db, `rooms/${currentRoom}`), { turn: playerColor === 'red' ? 'blue' : 'red' });
        }
    });
}

// ç›£è½é€²çƒåˆ¤å®š
setInterval(() => {
    if (!ball) return;
    // ç°¡å–®åˆ¤å®šï¼šå¦‚æœçƒè¶Šéä¸Šä¸‹é‚Šç•Œï¼Œç®—é€²çƒ (Goal)
    if (ball.position.y < 30) {
        scoreGoal('red');
    } else if (ball.position.y > height - 30) {
        scoreGoal('blue');
    }
}, 500);

function scoreGoal(team) {
    if (playerColor !== 'red') return; // åªç”±æˆ¿ä¸» (ç´…éšŠ) çµç®—åˆ†æ•¸ï¼Œé¿å…é‡è¤‡è¨ˆç®—
    let newScores = { ...scores };
    newScores[team] += 1;
    update(ref(db, `rooms/${currentRoom}`), { scores: newScores, resetFlag: Date.now() });

    if (newScores[team] >= 6) {
        alert(`${team === 'red' ? 'ç´…' : 'è—'}éšŠç²å‹ï¼`);
        update(ref(db, `rooms/${currentRoom}`), { scores: { red: 0, blue: 0 } });
    }
}

// === Firebase é€£ç·šé‚è¼¯ ===

document.getElementById('create-btn').addEventListener('click', () => {
    const roomId = Math.random().toString(36).substring(2, 6).toUpperCase();
    currentRoom = roomId;
    playerColor = 'red'; // æˆ¿ä¸»ç‚ºç´…éšŠ
    
    set(ref(db, `rooms/${roomId}`), {
        status: 'waiting',
        turn: 'red',
        scores: { red: 0, blue: 0 }
    }).then(() => {
        enterGameUI();
        listenToRoom();
    });
});

document.getElementById('join-btn').addEventListener('click', () => {
    const roomId = roomInput.value.trim().toUpperCase();
    if (!roomId) return alert("è«‹è¼¸å…¥æˆ¿è™Ÿ");
    
    get(ref(db, `rooms/${roomId}`)).then((snapshot) => {
        if (snapshot.exists() && snapshot.val().status === 'waiting') {
            currentRoom = roomId;
            playerColor = 'blue'; // åŠ å…¥è€…ç‚ºè—éšŠ
            
            update(ref(db, `rooms/${roomId}`), { status: 'playing' }).then(() => {
                enterGameUI();
                listenToRoom();
            });
        } else {
            alert("æˆ¿é–“ä¸å­˜åœ¨æˆ–å·²æ»¿");
        }
    });
});

function enterGameUI() {
    menuDiv.style.display = 'none';
    statusDiv.style.display = 'block';
    gameContainer.style.display = 'block';
    roomDisplay.innerText = `æˆ¿è™Ÿï¼š${currentRoom} (ä½ æ˜¯ ${playerColor === 'red' ? 'ğŸ”´ ç´…éšŠ' : 'ğŸ”µ è—éšŠ'})`;
    initPhysics();
}

let lastActionTime = 0;

function listenToRoom() {
    // ç›£è½æˆ¿é–“ç‹€æ…‹
    onValue(ref(db, `rooms/${currentRoom}`), (snapshot) => {
        const data = snapshot.val();
        if (!data) return;

        scores = data.scores || { red: 0, blue: 0 };
        scoreDisplay.innerText = `ğŸ”´ ç´…éšŠ ${scores.red} - ${scores.blue} è—éšŠ ğŸ”µ`;
        
        isMyTurn = (data.turn === playerColor);
        if (data.status === 'waiting') {
            turnDisplay.innerText = "ç­‰å¾…å°æ‰‹åŠ å…¥...";
            isMyTurn = false;
        } else {
            turnDisplay.innerText = isMyTurn ? "ğŸ‘‰ æ›ä½ æ‹‰å‹•çƒå“¡ï¼" : "â³ ç­‰å¾…å°æ‰‹æ“ä½œ...";
        }

        if (data.resetFlag && data.resetFlag > lastActionTime) {
            resetPositions();
            lastActionTime = data.resetFlag;
        }
    });

    // ç›£è½å°æ‰‹çš„å°„æ“Šå‹•ä½œ (Action Sync)
    onValue(ref(db, `rooms/${currentRoom}/action`), (snapshot) => {
        const action = snapshot.val();
        if (action && action.timestamp > lastActionTime) {
            lastActionTime = action.timestamp;
            const targetPlayer = players[action.playerId];
            if (targetPlayer) {
                // å¥—ç”¨å°æ‰‹å‚³ä¾†çš„åŠ›é“
                Matter.Body.applyForce(targetPlayer, targetPlayer.position, {
                    x: action.forceX,
                    y: action.forceY
                });
            }
        }
    });
}
