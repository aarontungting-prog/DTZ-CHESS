<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¿·ä½ è¶³çƒå°æˆ°</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <style>
        body {
            margin: 0; padding: 0;
            background-color: #1e3625; 
            color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex; flex-direction: column; align-items: center;
            overflow-x: hidden; touch-action: none;
            /* ç¢ºä¿æ•´å€‹ç•«é¢ä¸è¶…éè¦–çª—é«˜åº¦ï¼Œé˜²æ­¢æ»‘å‹• */
            height: 100vh; justify-content: flex-start;
        }

        #ui-container {
            text-align: center; margin-top: 2vh;
            width: 90%; max-width: 400px;
            background: #274e31; padding: 20px;
            border-radius: 20px; box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            box-sizing: border-box; flex-shrink: 0;
        }
        h1 { font-size: 24px; margin-top: 0; margin-bottom: 20px; display: flex; align-items: center; justify-content: center; gap: 10px;}
        
        button {
            padding: 12px 20px; font-size: 16px; cursor: pointer;
            border: none; border-radius: 12px; width: 100%;
            margin-bottom: 12px; font-weight: bold;
            transition: transform 0.1s; box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        button:active { transform: scale(0.98); }
        #single-btn { background-color: #2ecc71; color: #000; } 
        #create-btn { background-color: #f1c40f; color: #000; } 
        #join-btn { background-color: #3498db; color: #fff; }   
        
        input {
            padding: 12px; font-size: 16px; width: 100%; margin-bottom: 12px;
            border-radius: 12px; border: 2px solid #34495e;
            box-sizing: border-box; text-align: center; background: #ecf0f1; font-weight: bold;
        }

        #status-bar {
            display: none; width: 100%; max-width: 400px;
            background: #fff; color: #333;
            padding: 10px 0; text-align: center;
            font-size: 20px; font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            z-index: 10; flex-shrink: 0;
        }
        .score-red { color: #e74c3c; font-size: 24px;}
        .score-blue { color: #3498db; font-size: 24px;}

        /* å„ªåŒ–è‡ªé©æ‡‰ç¸®æ”¾ (Responsive Scaling) */
        #game-wrapper {
            display: none; width: 100%; flex-grow: 1;
            display: flex; justify-content: center; align-items: center;
            padding: 10px; box-sizing: border-box;
        }

        #game-container {
            position: relative;
            /* ä½¿ç”¨æœ€å¤§é«˜åº¦èˆ‡å¯¬åº¦é™åˆ¶ï¼Œä¸¦ä¿æŒ 2:3 æ¯”ä¾‹ */
            width: 100%; max-width: 400px;
            max-height: 65vh; /* é¿å…çƒé–€è¢«è£åˆ‡ */
            aspect-ratio: 2 / 3; 
            border-radius: 8px; overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        canvas {
            display: block; width: 100%; height: 100%;
            touch-action: none; background-color: #6fb93e;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 40px, rgba(0, 0, 0, 0.05) 40px, rgba(0, 0, 0, 0.05) 80px);
        }
    </style>
</head>
<body>

    <div id="status-bar">
        <span class="score-red" id="score-red">0</span>
        <span style="color: #aaa; margin: 0 15px;">VS</span>
        <span class="score-blue" id="score-blue">0</span>
        <div id="room-display" style="font-size: 12px; color: #7f8c8d; margin-top: 5px;"></div>
    </div>

    <div id="ui-container">
        <h1>âš½ è¿·ä½ è¶³çƒ</h1>
        <div id="menu">
            <button id="single-btn">å–®äººéŠç© (VS é›»è…¦)</button>
            <hr style="border:0; border-top:2px dashed #4a6b55; margin: 20px 0;">
            <button id="create-btn">å‰µå»ºé€£ç·šæˆ¿é–“</button>
            <input type="text" id="room-input" placeholder="è¼¸å…¥æˆ¿è™ŸåŠ å…¥...">
            <button id="join-btn">åŠ å…¥æˆ¿é–“</button>
        </div>
    </div>

    <div id="game-wrapper" style="display:none;">
        <div id="game-container">
            <canvas id="game-canvas"></canvas>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, get } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCnONA7vSsBwOcui-bVBmmZfD_TOVZmck0",
            authDomain: "airplane-game-68f8f.firebaseapp.com",
            projectId: "airplane-game-68f8f",
            storageBucket: "airplane-game-68f8f.firebasestorage.app",
            messagingSenderId: "215248477446",
            appId: "1:215248477446:web:f1d9dbb69b759118125287",
            measurementId: "G-GKWZMFT66H",
            databaseURL: "https://airplane-game-68f8f-default-rtdb.firebaseio.com/" 
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        let gameMode = 'single';
        let currentRoom = null;
        let playerColor = 'red'; 
        let scores = { red: 0, blue: 0 };

        const menuDiv = document.getElementById('ui-container');
        const statusBar = document.getElementById('status-bar');
        const gameWrapper = document.getElementById('game-wrapper');
        const roomDisplay = document.getElementById('room-display');
        const scoreRedDisplay = document.getElementById('score-red');
        const scoreBlueDisplay = document.getElementById('score-blue');

        const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
              Bodies = Matter.Bodies, Composite = Matter.Composite, Events = Matter.Events,
              Vector = Matter.Vector;

        let engine, render, runner;
        let ball;
        let players = [];
        const gameWidth = 400;
        const gameHeight = 600;

        function initPhysics() {
            engine = Engine.create();
            engine.world.gravity.y = 0; 
            
            render = Render.create({
                canvas: document.getElementById('game-canvas'),
                engine: engine,
                options: { width: gameWidth, height: gameHeight, wireframes: false, background: 'transparent' }
            });

            createPitch();
            resetGame(true);

            Events.on(render, 'afterRender', drawPitchLines);

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);
            
            setupSlingshotInteraction();
            if(gameMode === 'single') setInterval(triggerAILogic, 1000); // æ¯ç§’è§¸ç™¼ AI
        }

        function createPitch() {
            const wallOptions = { isStatic: true, render: { fillStyle: 'transparent' } }; 
            const goalWidth = 120;
            const goalLeft = (gameWidth - goalWidth) / 2;
            const goalRight = goalLeft + goalWidth;

            const walls = [
                Bodies.rectangle(-10, gameHeight/2, 20, gameHeight, wallOptions),
                Bodies.rectangle(gameWidth+10, gameHeight/2, 20, gameHeight, wallOptions),
                Bodies.rectangle(goalLeft/2, -10, goalLeft, 20, wallOptions),
                Bodies.rectangle(goalRight + goalLeft/2, -10, goalLeft, 20, wallOptions),
                Bodies.rectangle(goalLeft/2, gameHeight+10, goalLeft, 20, wallOptions),
                Bodies.rectangle(goalRight + goalLeft/2, gameHeight+10, goalLeft, 20, wallOptions),
                Bodies.rectangle(gameWidth/2, -30, goalWidth, 20, wallOptions), 
                Bodies.rectangle(gameWidth/2, gameHeight+30, goalWidth, 20, wallOptions), 
                Bodies.rectangle(goalLeft-5, -15, 10, 30, wallOptions), 
                Bodies.rectangle(goalRight+5, -15, 10, 30, wallOptions),
                Bodies.rectangle(goalLeft-5, gameHeight+15, 10, 30, wallOptions), 
                Bodies.rectangle(goalRight+5, gameHeight+15, 10, 30, wallOptions)
            ];
            Composite.add(engine.world, walls);
        }

        function drawPitchLines() {
            const ctx = render.context;
            ctx.strokeStyle = 'rgba(255,255,255,0.7)';
            ctx.lineWidth = 3;

            ctx.beginPath();
            ctx.moveTo(0, gameHeight/2); ctx.lineTo(gameWidth, gameHeight/2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(gameWidth/2, gameHeight/2, 50, 0, 2 * Math.PI);
            ctx.stroke();

            const goalW = 120; const goalH = 25;
            ctx.fillStyle = 'rgba(231, 76, 60, 0.4)'; 
            ctx.fillRect((gameWidth-goalW)/2, 0, goalW, goalH);
            ctx.strokeRect((gameWidth-goalW)/2, 0, goalW, goalH);

            ctx.fillStyle = 'rgba(52, 152, 219, 0.4)'; 
            ctx.fillRect((gameWidth-goalW)/2, gameHeight-goalH, goalW, goalH);
            ctx.strokeRect((gameWidth-goalW)/2, gameHeight-goalH, goalW, goalH);

            if (dragState.isDragging && dragState.player) {
                ctx.beginPath();
                ctx.moveTo(dragState.player.position.x, dragState.player.position.y);
                ctx.lineTo(dragState.currentX, dragState.currentY);
                ctx.strokeStyle = playerColor === 'red' ? 'rgba(231,76,60,0.8)' : 'rgba(52,152,219,0.8)';
                ctx.lineWidth = 5; ctx.setLineDash([10, 10]); ctx.stroke(); ctx.setLineDash([]);
            }
        }

        function resetGame(fullReset = false) {
            if(ball) Composite.remove(engine.world, ball);
            
            ball = Bodies.circle(gameWidth/2, gameHeight/2, 12, { 
                restitution: 0.9, frictionAir: 0.01, density: 0.002,
                render: { fillStyle: '#ffffff', strokeStyle: '#000', lineWidth: 2 } 
            });
            Composite.add(engine.world, ball);

            if (fullReset) {
                players.forEach(p => Composite.remove(engine.world, p));
                players = [];
                
                const bluePos = [{x: 120, y: 150}, {x: 280, y: 150}, {x: 200, y: 250}];
                const redPos = [{x: 120, y: 450}, {x: 280, y: 450}, {x: 200, y: 350}];

                // ğŸŒŸ å„ªåŒ– 1ï¼šåŠ å…¥éš¨æ©Ÿåç§» (Random Offset) é¿å…çƒå“¡æ“ åœ¨ä¸€èµ·
                const createTeam = (positions, color) => {
                    positions.forEach(pos => {
                        let offsetX = (Math.random() - 0.5) * 40; 
                        let offsetY = (Math.random() - 0.5) * 40;
                        let player = Bodies.circle(pos.x + offsetX, pos.y + offsetY, 20, {
                            restitution: 0.8, frictionAir: 0.05, density: 0.01,
                            render: { fillStyle: color === 'blue' ? '#3498db' : '#e74c3c', strokeStyle: '#2c3e50', lineWidth: 3 },
                            team: color
                        });
                        players.push(player);
                        Composite.add(engine.world, player);
                    });
                };
                createTeam(bluePos, 'blue');
                createTeam(redPos, 'red');
            }
        }

        let dragState = { isDragging: false, player: null, startX: 0, startY: 0, currentX: 0, currentY: 0 };
        
        function setupSlingshotInteraction() {
            const canvas = render.canvas;
            
            const getTouchPos = (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
            };

            const onStart = (e) => {
                const pos = getTouchPos(e);
                let bodies = Matter.Query.point(players, pos);
                let myPlayer = bodies.find(b => b.team === playerColor);
                
                if (myPlayer) {
                    dragState.isDragging = true; dragState.player = myPlayer;
                    dragState.startX = pos.x; dragState.startY = pos.y;
                    dragState.currentX = pos.x; dragState.currentY = pos.y;
                }
            };

            const onMove = (e) => {
                if (!dragState.isDragging) return;
                const pos = getTouchPos(e);
                dragState.currentX = pos.x; dragState.currentY = pos.y;
            };

            const onEnd = () => {
                if (!dragState.isDragging || !dragState.player) return;
                
                // ğŸŒŸ å„ªåŒ– 3ï¼šå¢åŠ æ‹–æ‹‰åŠ›åº¦ (Force Multiplier) è®“æ“ä½œæ›´éˆæ•
                let forceMultiplier = 0.0004; 
                let dx = dragState.startX - dragState.currentX;
                let dy = dragState.startY - dragState.currentY;
                let forceX = dx * forceMultiplier;
                let forceY = dy * forceMultiplier;

                applyAction(players.indexOf(dragState.player), forceX, forceY);

                if (gameMode === 'multi') {
                    set(ref(db, `rooms/${currentRoom}/action`), {
                        playerId: players.indexOf(dragState.player), forceX, forceY, timestamp: Date.now()
                    });
                }
                dragState.isDragging = false; dragState.player = null;
            };

            canvas.addEventListener('mousedown', onStart);
            canvas.addEventListener('mousemove', onMove);
            canvas.addEventListener('mouseup', onEnd);
            canvas.addEventListener('touchstart', onStart, {passive: false});
            canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); onMove(e); }, {passive: false});
            canvas.addEventListener('touchend', onEnd);
        }

        function applyAction(playerId, forceX, forceY) {
            const player = players[playerId];
            if (player) Matter.Body.applyForce(player, player.position, { x: forceX, y: forceY });
        }

        // ğŸŒŸ å„ªåŒ– 4ï¼šè®“ AI å°‹æ‰¾æœ€è¿‘çš„çƒå“¡æ’æ“Šè¶³çƒ (Aggressive AI)
        function triggerAILogic() {
            if (!ball) return;
            let nearest = null;
            let minDist = Infinity;
            
            players.filter(p => p.team === 'blue').forEach(bot => {
                let dist = Vector.magnitude(Vector.sub(ball.position, bot.position));
                if(dist < minDist){ nearest = bot; minDist = dist; }
            });
            
            if(nearest){
                let dir = Vector.normalise(Vector.sub(ball.position, nearest.position));
                // çµ¦äºˆä¸€å€‹å¼·å‹çš„è¡æ’åŠ›é“
                Matter.Body.applyForce(nearest, nearest.position, { x: dir.x * 0.02, y: dir.y * 0.02 });
            }
        }

        setInterval(() => {
            if (!ball) return;
            if (ball.position.y < 10) scoreGoal('red');
            else if (ball.position.y > gameHeight - 10) scoreGoal('blue');
        }, 300);

        function scoreGoal(team) {
            if (gameMode === 'multi' && playerColor !== 'red') return; 
            
            let newScores = { ...scores };
            newScores[team] += 1;
            
            if (gameMode === 'multi') {
                update(ref(db, `rooms/${currentRoom}`), { scores: newScores, ballResetFlag: Date.now() });
            } else {
                scores = newScores;
                updateScoreUI(); resetGame(false); 
            }
            checkWin(newScores, team);
        }

        function checkWin(currentScores, team) {
            if (currentScores[team] >= 6) {
                setTimeout(() => {
                    alert(`${team === 'red' ? 'ğŸ”´ ç´…éšŠ' : 'ğŸ”µ è—éšŠ'} ç²å‹ï¼`);
                    scores = { red: 0, blue: 0 };
                    if (gameMode === 'multi') {
                        update(ref(db, `rooms/${currentRoom}`), { scores: scores, fullResetFlag: Date.now() });
                    } else {
                        updateScoreUI(); resetGame(true); 
                    }
                }, 100);
            }
        }

        function updateScoreUI() {
            scoreRedDisplay.innerText = scores.red;
            scoreBlueDisplay.innerText = scores.blue;
        }
        
        function enterGameUI(modeText) {
            menuDiv.style.display = 'none';
            statusBar.style.display = 'flex';
            statusBar.style.justifyContent = 'center'; statusBar.style.alignItems = 'center';
            gameWrapper.style.display = 'flex'; // é¡¯ç¤ºåŒ…è¦†å±¤
            roomDisplay.innerText = modeText;
            initPhysics();
        }

        document.getElementById('single-btn').addEventListener('click', () => {
            gameMode = 'single'; playerColor = 'red'; scores = { red: 0, blue: 0 };
            updateScoreUI(); enterGameUI("å–®äººæ¨¡å¼");
        });

        document.getElementById('create-btn').addEventListener('click', () => {
            gameMode = 'multi';
            const roomId = Math.random().toString(36).substring(2, 6).toUpperCase();
            set(ref(db, `rooms/${roomId}`), { scores: { red: 0, blue: 0 } }).then(() => {
                currentRoom = roomId; playerColor = 'red'; 
                enterGameUI(`æˆ¿è™Ÿ: ${roomId} (ä½ æ˜¯ ğŸ”´)`); listenToRoom();
            }).catch(err => alert("æ¬Šé™éŒ¯èª¤: " + err.message));
        });

        document.getElementById('join-btn').addEventListener('click', () => {
            gameMode = 'multi';
            const roomId = document.getElementById('room-input').value.trim().toUpperCase();
            if (!roomId) return alert("è«‹è¼¸å…¥æˆ¿è™Ÿ");
            
            get(ref(db, `rooms/${roomId}`)).then((snapshot) => {
                if (snapshot.exists()) {
                    currentRoom = roomId; playerColor = 'blue'; 
                    enterGameUI(`æˆ¿è™Ÿ: ${roomId} (ä½ æ˜¯ ğŸ”µ)`); listenToRoom();
                } else alert("æˆ¿é–“ä¸å­˜åœ¨ï¼");
            });
        });

        let lastActionTime = 0; let lastBallReset = 0; let lastFullReset = 0;

        function listenToRoom() {
            onValue(ref(db, `rooms/${currentRoom}`), (snapshot) => {
                const data = snapshot.val();
                if (!data) return;

                scores = data.scores || { red: 0, blue: 0 }; updateScoreUI();

                if (data.ballResetFlag && data.ballResetFlag > lastBallReset) {
                    resetGame(false); lastBallReset = data.ballResetFlag;
                }
                if (data.fullResetFlag && data.fullResetFlag > lastFullReset) {
                    resetGame(true); lastFullReset = data.fullResetFlag;
                }
            });

            onValue(ref(db, `rooms/${currentRoom}/action`), (snapshot) => {
                const action = snapshot.val();
                if (action && action.timestamp > lastActionTime && players[action.playerId]) {
                    lastActionTime = action.timestamp;
                    applyAction(action.playerId, action.forceX, action.forceY);
                }
            });
        }
    </script>
</body>
</html>
