<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>è¿·ä½ è¶³çƒ Pocket Soccer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Noto+Sans+TC:wght@700;900&display=swap');

        /* é–å®šå…¨è¢å¹•ï¼Œé˜²æ­¢æ‰‹æ©Ÿæ»‘å‹• */
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #f3a683; /* å¾©åˆ»æˆªåœ–çš„ç²‰æ©˜è‰²èƒŒæ™¯ */
            font-family: 'Fredoka One', 'Noto Sans TC', sans-serif;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            overflow: hidden; position: fixed; inset: 0; touch-action: none; user-select: none; -webkit-user-select: none;
        }

        /* ===== è‡ªè¨‚æç¤ºæ¡† (Toast) ===== */
        #toast {
            position: fixed; top: -100px; left: 50%; transform: translateX(-50%);
            background-color: #34495e; color: white; padding: 15px 30px; border-radius: 30px;
            font-size: 16px; font-family: 'Noto Sans TC', sans-serif; font-weight: bold; 
            z-index: 9999; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            transition: top 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55); text-align: center; white-space: nowrap;
        }

        /* ===== ä¸»é¸å–® UI (å°ˆæ¥­æ‰å¹³åŒ–) ===== */
        #menu-container {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100%; width: 100%; z-index: 50; position: absolute; 
            background-color: #a4c639; /* æ¸…æ–°è‰ç¶ è‰²é¦–é  */
        }
        .menu-title {
            color: white; font-size: 48px; margin-bottom: 20px;
            text-shadow: 3px 3px 0px rgba(0,0,0,0.15); letter-spacing: 2px;
            display: flex; flex-direction: column; align-items: center;
        }
        .menu-subtitle {
            font-size: 16px; color: #f1f2f6; font-family: 'Noto Sans TC', sans-serif;
            text-align: center; margin-bottom: 50px; line-height: 1.5; font-weight: bold;
        }
        
        .menu-btn {
            width: 280px; padding: 15px 20px; font-size: 24px; border: none; border-radius: 12px;
            cursor: pointer; margin-bottom: 20px; transition: transform 0.1s;
            font-family: 'Fredoka One', 'Noto Sans TC', sans-serif; color: white; 
            display: flex; align-items: center; justify-content: center; gap: 15px;
            box-shadow: 0 6px 0px rgba(0,0,0,0.2);
        }
        .menu-btn:active { transform: translateY(6px); box-shadow: 0 0px 0px rgba(0,0,0,0); }
        .btn-single { background-color: #54a0ff; }
        .btn-multi { background-color: #ff6b6b; }
        
        .input-group {
            display: flex; width: 280px; gap: 10px; margin-bottom: 20px;
        }
        .input-box {
            flex-grow: 1; padding: 15px; font-size: 20px; border-radius: 12px; border: none;
            text-align: center; font-family: 'Fredoka One', sans-serif; outline: none;
            box-shadow: inset 0 4px 6px rgba(0,0,0,0.1);
        }
        .btn-join {
            width: 80px; padding: 15px; background-color: #1dd1a1; color: white; 
            border: none; border-radius: 12px; font-size: 20px; font-weight: bold;
            box-shadow: 0 6px 0px rgba(0,0,0,0.2); cursor: pointer;
        }
        .btn-join:active { transform: translateY(6px); box-shadow: 0 0px 0px rgba(0,0,0,0); }

        /* ===== éŠæˆ²ç•«é¢ ===== */
        #game-ui { display: none; flex-direction: column; align-items: center; width: 100%; height: 100%; position: relative; }
        
        /* é ‚éƒ¨æ§åˆ¶åˆ— (å®Œç¾å¾©åˆ»æˆªåœ–) */
        #top-bar {
            width: 100%; max-width: 400px; display: flex; align-items: center; justify-content: space-between;
            padding: 15px 20px; box-sizing: border-box; z-index: 10; margin-bottom: 5px;
        }
        #btn-exit {
            width: 45px; height: 45px; background: white; border-radius: 50%;
            display: flex; justify-content: center; align-items: center; color: #ff6b6b;
            font-size: 24px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 0 rgba(0,0,0,0.1); border: none;
        }
        #btn-exit:active { transform: translateY(4px); box-shadow: 0 0 0 rgba(0,0,0,0); }

        /* è¨ˆåˆ†æ¿ */
        #scoreboard {
            background: #503d3f; color: white; width: 220px; padding: 8px 15px; border-radius: 20px;
            display: flex; justify-content: space-between; align-items: center; font-size: 24px;
            box-shadow: 0 6px 0 rgba(0,0,0,0.15); margin: 0 auto;
        }
        .score-col { display: flex; flex-direction: column; align-items: center; line-height: 1.1; }
        .team-name { font-size: 11px; opacity: 0.8; font-family: 'Fredoka One', sans-serif; text-transform: uppercase;}
        .score-red { color: #ff6b6b; font-size: 28px; }
        .score-blue { color: #4ea8de; font-size: 28px; }
        .score-vs { font-size: 20px; color: #dcdde1; }

        /* å‹•æ…‹ç¸®æ”¾å±¤ */
        #scaling-wrapper { 
            position: relative; width: 400px; height: 720px; 
            transform-origin: top center;
        }
        canvas { display: block; width: 100%; height: 100%; outline: none; }

        /* æ©«å¹…æç¤º */
        .turn-banner {
            position: absolute; padding: 12px 35px; border-radius: 30px; font-size: 22px; font-weight: normal;
            color: white; z-index: 20; transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none; opacity: 0; box-shadow: 0 6px 15px rgba(0,0,0,0.2); left: 50%; transform: translateX(-50%) scale(0.8);
        }
        .turn-banner.active { opacity: 1; transform: translateX(-50%) scale(1); }
        #bot-banner { top: 90px; background-color: #503d3f; }
        #player-banner { bottom: 90px; background-color: #ff6b6b; }
        
        /* ç­‰å¾…æˆ¿é–“æç¤º */
        #waiting-overlay {
            position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95); padding: 25px 40px; border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2); text-align: center; z-index: 30;
            display: none; flex-direction: column; align-items: center; border: 4px solid #ff6b6b;
        }
        #waiting-room-id { font-size: 42px; color: #ff6b6b; margin: 10px 0; letter-spacing: 3px; }
        .waiting-text { font-size: 16px; color: #503d3f; font-family: 'Noto Sans TC'; font-weight: bold;}

        /* çµç®—ç•«é¢ */
        #win-modal {
            display: none; position: absolute; inset: 0; background: rgba(0,0,0,0.7); z-index: 100; flex-direction: column; justify-content: center; align-items: center;
        }
        .win-box { background: #fff; padding: 40px; border-radius: 25px; text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.4); border: 6px solid #503d3f; width: 80%; max-width: 300px; }
        #win-text { font-size: 40px; color: #ff6b6b; margin-bottom: 30px; text-transform: uppercase;}
    </style>
</head>
<body>

    <div id="toast">æç¤ºè¨Šæ¯</div>

    <div id="menu-container">
        <div class="menu-title">
            âš½ POCKET<br>SOCCER
        </div>
        <div class="menu-subtitle">
            æ‹–å‹•çƒå“¡æ§åˆ¶ä½ çš„å°éšŠï¼Œ<br>ç‡å…ˆç²å¾— 3 ç²’é€²çƒè´å¾—å‹åˆ©ï¼
        </div>

        <button class="menu-btn btn-single" id="btn-single">ğŸ‘¤ VS ğŸ¤–</button>
        <button class="menu-btn btn-multi" id="btn-create">ğŸ‘¤ VS ğŸ‘¤ (å»ºç«‹)</button>
        
        <div class="input-group">
            <input type="text" id="input-room" class="input-box" placeholder="è¼¸å…¥æˆ¿è™ŸåŠ å…¥..." maxlength="4">
            <button class="btn-join" id="btn-join">GO</button>
        </div>
    </div>

    <div id="game-ui">
        <div id="top-bar">
            <button id="btn-exit">ï¼œ</button>
            <div id="scoreboard">
                <div class="score-col">
                    <span class="team-name" style="color: #ff6b6b;">YOU</span>
                    <span class="score-red" id="score-red">0</span>
                </div>
                <span class="score-vs">VS</span>
                <div class="score-col">
                    <span class="team-name" style="color: #4ea8de;" id="p2-name">BOT</span>
                    <span class="score-blue" id="score-blue">0</span>
                </div>
            </div>
            <div style="width: 45px;"></div> </div>

        <div id="scaling-wrapper">
            <canvas id="game-canvas"></canvas>
            
            <div class="turn-banner" id="bot-banner">OPPONENT THINKING...</div>
            <div class="turn-banner" id="player-banner">YOUR TURN!</div>
            
            <div id="waiting-overlay">
                <div class="waiting-text">ç­‰å¾…å°æ‰‹åŠ å…¥</div>
                <div id="waiting-room-id">0000</div>
                <div class="waiting-text" style="font-size: 13px; color: #888;">å°‡æ­¤æˆ¿è™Ÿå‘Šè¨´ä½ çš„æœ‹å‹</div>
            </div>
        </div>
    </div>

    <div id="win-modal">
        <div class="win-box">
            <div id="win-text">YOU WON!</div>
            <button class="menu-btn btn-single" style="width: 100%; font-size: 20px;" id="btn-rematch">PLAY AGAIN</button>
            <button class="menu-btn btn-multi" style="width: 100%; font-size: 20px;" id="btn-home">MAIN MENU</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, get, onDisconnect } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-database.js";

        function showToast(msg, isError = false) {
            const toast = document.getElementById('toast');
            toast.innerText = msg;
            toast.style.backgroundColor = isError ? '#e74c3c' : '#2ecc71';
            toast.style.top = '40px'; 
            setTimeout(() => { toast.style.top = '-100px'; }, 3000); 
        }

        // Firebase åˆå§‹åŒ– (æ±å—äºä¼ºæœå™¨)
        let db = null;
        try {
            const firebaseConfig = {
                apiKey: "AIzaSyCnONA7vSsBwOcui-bVBmmZfD_TOVZmck0",
                authDomain: "airplane-game-68f8f.firebaseapp.com",
                projectId: "airplane-game-68f8f",
                storageBucket: "airplane-game-68f8f.firebasestorage.app",
                messagingSenderId: "215248477446",
                appId: "1:215248477446:web:f1d9dbb69b759118125287",
                databaseURL: "https://airplane-game-68f8f-default-rtdb.asia-southeast1.firebasedatabase.app/" 
            };
            db = getDatabase(initializeApp(firebaseConfig));
        } catch (e) { console.warn("Firebase åˆå§‹åŒ–å¤±æ•—"); }

        // è¢å¹•è‡ªé©æ‡‰ç¸®æ”¾
        const scaleWrapper = document.getElementById('scaling-wrapper');
        let currentScale = 1;
        function resizeGame() {
            const topBarHeight = document.getElementById('top-bar').offsetHeight || 80;
            const availableHeight = window.innerHeight - topBarHeight - 10; 
            const availableWidth = window.innerWidth - 10;
            currentScale = Math.min(availableWidth / 400, availableHeight / 720);
            scaleWrapper.style.transform = `scale(${currentScale})`;
        }
        window.addEventListener('resize', resizeGame);
        setTimeout(resizeGame, 100);

        // éŠæˆ²ç‹€æ…‹èˆ‡ç‰©ç†å¼•æ“è®Šæ•¸
        let gameMode = 'single', currentRoom = null, myTeam = 'red', currentTurn = 'red', isMoving = false;
        let roomStatus = 'ended'; // waiting, playing, ended
        let scores = { red: 0, blue: 0 };
        const WIN_SCORE = 3;

        const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
              Bodies = Matter.Bodies, Composite = Matter.Composite, Events = Matter.Events, Vector = Matter.Vector;
        
        // çƒå ´å°ºå¯¸å®šç¾©
        const gameWidth = 400, gameHeight = 720;
        const fieldTop = 80, fieldBottom = 640; 
        const goalW = 150, goalH = 45;
        const leftW = (gameWidth - goalW) / 2;

        let engine, render, runner, ball, players = [];
        let trails = [];
        let bannerTimer = null;

        function initGame() {
            if(engine) { Matter.Engine.clear(engine); Render.stop(render); Runner.stop(runner); document.getElementById('game-canvas').remove(); }
            
            const canvasObj = document.createElement('canvas'); canvasObj.id = 'game-canvas';
            scaleWrapper.insertBefore(canvasObj, scaleWrapper.firstChild);

            engine = Engine.create(); engine.world.gravity.y = 0; 
            render = Render.create({ canvas: canvasObj, engine: engine, options: { width: gameWidth, height: gameHeight, wireframes: false, background: 'transparent' } });

            createBoundaries(); resetFormation(true);
            Events.on(render, 'afterRender', customDraw); Events.on(engine, 'afterUpdate', physicsUpdate);

            Render.run(render); runner = Runner.create(); Runner.run(runner, engine);
            setupSlingshot(canvasObj); resizeGame();
        }

        function createBoundaries() {
            // ç‰†å£æ‘©æ“¦åŠ›å…¨é—œï¼Œå½ˆæ€§ 0.9 è®“åå½ˆé †æš¢ä¹¾æ·¨
            const wallOpts = { isStatic: true, render: { visible: false }, restitution: 0.9, friction: 0, frictionStatic: 0 };
            const postOpts = { isStatic: true, render: { visible: false }, restitution: 0.8, friction: 0, frictionStatic: 0 };
            
            const walls = [
                Bodies.rectangle(-10, gameHeight/2, 20, gameHeight, wallOpts), Bodies.rectangle(gameWidth+10, gameHeight/2, 20, gameHeight, wallOpts),
                Bodies.rectangle(leftW/2, fieldTop-10, leftW, 20, wallOpts), Bodies.rectangle(gameWidth - leftW/2, fieldTop-10, leftW, 20, wallOpts),
                Bodies.rectangle(leftW/2, fieldBottom+10, leftW, 20, wallOpts), Bodies.rectangle(gameWidth - leftW/2, fieldBottom+10, leftW, 20, wallOpts),
                // çƒç¶²èƒŒæ¿
                Bodies.rectangle(gameWidth/2, fieldTop - goalH - 10, goalW, 20, wallOpts), Bodies.rectangle(gameWidth/2, fieldBottom + goalH + 10, goalW, 20, wallOpts),
                // å´ç¶²
                Bodies.rectangle(leftW-10, fieldTop - goalH/2, 20, goalH, wallOpts), Bodies.rectangle(gameWidth-leftW+10, fieldTop - goalH/2, 20, goalH, wallOpts),
                Bodies.rectangle(leftW-10, fieldBottom + goalH/2, 20, goalH, wallOpts), Bodies.rectangle(gameWidth-leftW+10, fieldBottom + goalH/2, 20, goalH, wallOpts),
                // ç‰©ç†é–€æŸ±
                Bodies.circle(leftW, fieldTop, 8, postOpts), Bodies.circle(gameWidth - leftW, fieldTop, 8, postOpts),
                Bodies.circle(leftW, fieldBottom, 8, postOpts), Bodies.circle(gameWidth - leftW, fieldBottom, 8, postOpts)
            ];
            Composite.add(engine.world, walls);
        }

        function resetFormation(fullReset = false) {
            if(ball) Composite.remove(engine.world, ball);
            players.forEach(p => Composite.remove(engine.world, p)); players = []; trails = [];
            if(fullReset) { scores = { red: 0, blue: 0 }; updateScoreUI(); }

            // è¶³çƒï¼šæ¥µè¼•ã€ä½é˜»åŠ›
            ball = Bodies.circle(gameWidth/2, gameHeight/2, 12, { 
                restitution: 0.9, frictionAir: 0.015, friction: 0, frictionStatic: 0, density: 0.002, render: { visible: false }, label: 'ball'
            });
            Composite.add(engine.world, ball);

            // çƒå“¡ï¼šç¨é‡ã€æœ‰ä¸€å®šé˜»åŠ›(æ»‘è¡Œå¾Œåœä¸‹)ï¼Œé«˜å½ˆæ€§
            const pOpts = { restitution: 0.85, frictionAir: 0.03, friction: 0, frictionStatic: 0, density: 0.05, render: { visible: false } };
            
            const bluePos = [ {x: gameWidth/2, y: fieldTop + 130}, {x: gameWidth/2 - 80, y: fieldTop + 220}, {x: gameWidth/2 + 80, y: fieldTop + 220}, {x: gameWidth/2 - 70, y: fieldTop + 50}, {x: gameWidth/2 + 70, y: fieldTop + 50} ];
            const redPos = [ {x: gameWidth/2, y: fieldBottom - 130}, {x: gameWidth/2 - 80, y: fieldBottom - 220}, {x: gameWidth/2 + 80, y: fieldBottom - 220}, {x: gameWidth/2 - 70, y: fieldBottom - 50}, {x: gameWidth/2 + 70, y: fieldBottom - 50} ];

            bluePos.forEach(p => { let b = Bodies.circle(p.x, p.y, 22, pOpts); b.team = 'blue'; players.push(b); });
            redPos.forEach(p => { let b = Bodies.circle(p.x, p.y, 22, pOpts); b.team = 'red'; players.push(b); });
            Composite.add(engine.world, players);
            
            isMoving = false; currentTurn = 'red'; 
            if(roomStatus === 'playing') updateTurnBanner();
        }

        // === å°ˆæ¥­ç´šæ‰å¹³åŒ–ç¹ªåœ– ===
        function customDraw() {
            const ctx = render.context; const time = engine.timing.timestamp;
            
            // ç•«çƒå ´ç¶ åœ°èˆ‡ç™½è‰²é‚Šæ¡†
            ctx.fillStyle = '#72c84b';
            ctx.beginPath(); ctx.rect(0, fieldTop, gameWidth, fieldBottom - fieldTop); ctx.fill();
            
            ctx.fillStyle = 'rgba(0,0,0,0.05)'; // è‰çš®æ·±æ·ºç´‹è·¯
            for(let y = fieldTop; y < fieldBottom; y += 80) { ctx.fillRect(0, y, gameWidth, 40); }

            ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 6; ctx.lineJoin = 'round';
            ctx.strokeRect(0, fieldTop, gameWidth, fieldBottom - fieldTop);
            
            // ä¸­ç·šèˆ‡ä¸­åœˆ
            ctx.beginPath(); ctx.moveTo(0, gameHeight/2); ctx.lineTo(gameWidth, gameHeight/2); ctx.stroke();
            ctx.beginPath(); ctx.arc(gameWidth/2, gameHeight/2, 50, 0, 2*Math.PI); ctx.stroke();
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(gameWidth/2, gameHeight/2, 8, 0, 2*Math.PI); ctx.fill();
            
            // ç•«å‡¸å‡ºçš„çƒç¶²èˆ‡ã„‡å­—æ¡†
            function drawGoal(x, y, isTop) {
                ctx.fillStyle = isTop ? '#4ea8de' : '#ff6b6b'; ctx.fillRect(x, y, goalW, goalH);
                ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = 2; ctx.beginPath();
                for(let i=6; i<goalW; i+=12) { ctx.moveTo(x+i, y); ctx.lineTo(x+i, y+goalH); }
                for(let i=6; i<goalH; i+=12) { ctx.moveTo(x, y+i); ctx.lineTo(x+goalW, y+i); }
                ctx.stroke();

                ctx.strokeStyle = '#2d3436'; ctx.lineWidth = 8; ctx.beginPath();
                if(isTop) { ctx.moveTo(x, y+goalH); ctx.lineTo(x, y); ctx.lineTo(x+goalW, y); ctx.lineTo(x+goalW, y+goalH); } 
                else { ctx.moveTo(x, y); ctx.lineTo(x, y+goalH); ctx.lineTo(x+goalW, y+goalH); ctx.lineTo(x+goalW, y); }
                ctx.stroke();

                ctx.fillStyle = '#ffffff'; ctx.strokeStyle = '#2d3436'; ctx.lineWidth = 3;
                let postY = isTop ? y+goalH : y;
                ctx.beginPath(); ctx.arc(x, postY, 6, 0, 2*Math.PI); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.arc(x+goalW, postY, 6, 0, 2*Math.PI); ctx.fill(); ctx.stroke();
            }
            drawGoal(leftW, fieldTop - goalH, true);
            drawGoal(leftW, fieldBottom, false);

            // æ‹–å°¾ç‰¹æ•ˆ
            trails.forEach(t => { ctx.globalAlpha = t.alpha; ctx.fillStyle = t.color; ctx.beginPath(); ctx.arc(t.x, t.y, t.size, 0, Math.PI*2); ctx.fill(); });
            ctx.globalAlpha = 1.0;

            // æ‰‡å½¢ç„æº–å€
            if (dragState.isDragging && dragState.player && roomStatus === 'playing') {
                let dx = dragState.currentX - dragState.startX; let dy = dragState.currentY - dragState.startY;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 10) { 
                    let angle = Math.atan2(dy, dx); let fanRadius = Math.min(dist * 1.5, 200); 
                    ctx.beginPath(); ctx.moveTo(dragState.player.position.x, dragState.player.position.y);
                    ctx.arc(dragState.player.position.x, dragState.player.position.y, fanRadius, angle - 0.35, angle + 0.35);
                    ctx.closePath(); ctx.fillStyle = 'rgba(74, 59, 50, 0.4)'; ctx.fill(); 
                }
            }

            // ğŸŒŸ ç¹ªè£½åˆ†é›¢å¼æ‰å¹³é™°å½± (Drop Shadow) -> åç§» (0, 5)
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath(); ctx.arc(ball.position.x, ball.position.y + 4, 12, 0, 2*Math.PI); ctx.fill();
            players.forEach(p => {
                ctx.beginPath(); ctx.arc(p.position.x, p.position.y + 6, 22, 0, 2*Math.PI); ctx.fill();
            });

            // ç¹ªè£½è¶³çƒ
            ctx.save(); ctx.translate(ball.position.x, ball.position.y); ctx.rotate(ball.angle); 
            ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(0, 0, 12, 0, 2*Math.PI); ctx.fill(); 
            ctx.lineWidth = 3; ctx.strokeStyle = '#2d3436'; ctx.stroke();
            ctx.fillStyle = '#2d3436';
            ctx.beginPath(); ctx.arc(0, 0, 4.5, 0, 2*Math.PI); ctx.fill(); 
            ctx.beginPath(); ctx.arc(8, 0, 3, 0, 2*Math.PI); ctx.fill(); 
            ctx.beginPath(); ctx.arc(-5, 6, 3, 0, 2*Math.PI); ctx.fill(); 
            ctx.beginPath(); ctx.arc(-5, -6, 3, 0, 2*Math.PI); ctx.fill(); 
            ctx.restore();

            // ç¹ªè£½çƒå“¡
            players.forEach(p => {
                if(p.team === currentTurn && !isMoving && currentTurn === myTeam && roomStatus === 'playing') {
                    ctx.save(); ctx.translate(p.position.x, p.position.y); ctx.rotate(time * 0.003);
                    ctx.setLineDash([10, 10]); ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.arc(0, 0, 32, 0, Math.PI*2); ctx.stroke(); ctx.restore();
                }
                ctx.fillStyle = p.team === 'red' ? '#ff6b6b' : '#4ea8de';
                ctx.beginPath(); ctx.arc(p.position.x, p.position.y, 22, 0, 2*Math.PI); ctx.fill(); 
                ctx.lineWidth = 4; ctx.strokeStyle = '#2d3436'; ctx.stroke();
                drawStar(ctx, p.position.x, p.position.y, 5, 12, 5.5);
            });
        }

        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3; let x = cx; let y = cy; let step = Math.PI / spikes; ctx.beginPath();
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step;
                x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius); ctx.closePath(); ctx.fillStyle = '#ffffff'; ctx.fill();
        }

        function physicsUpdate() {
            // ğŸŒŸ é˜²å¡æ­»æ©Ÿåˆ¶ï¼šçƒå“¡ä¸èƒ½é€²çƒé–€å€
            players.forEach(p => {
                if (p.position.y < fieldTop + 15) {
                    Matter.Body.setPosition(p, { x: p.position.x, y: fieldTop + 25 });
                    Matter.Body.setVelocity(p, { x: p.velocity.x, y: Math.max(0, p.velocity.y) });
                } else if (p.position.y > fieldBottom - 15) {
                    Matter.Body.setPosition(p, { x: p.position.x, y: fieldBottom - 25 });
                    Matter.Body.setVelocity(p, { x: p.velocity.x, y: Math.min(0, p.velocity.y) });
                }
            });

            checkTurnState();
            
            if (isMoving) {
                players.forEach(p => { if (p.speed > 3) trails.push({ x: p.position.x, y: p.position.y, size: 8, alpha: 0.5, color: p.team === 'red' ? '#ff6b6b' : '#4ea8de' }); });
                if (ball.speed > 3) trails.push({ x: ball.position.x, y: ball.position.y, size: 6, alpha: 0.5, color: 'rgba(255,255,255,0.8)' });
            }
            for (let i = trails.length - 1; i >= 0; i--) { trails[i].alpha -= 0.03; trails[i].size -= 0.15; if (trails[i].alpha <= 0 || trails[i].size <= 0) trails.splice(i, 1); }
        }

        let dragState = { isDragging: false, player: null, startX: 0, startY: 0, currentX: 0, currentY: 0 };
        function setupSlingshot(canvas) {
            const getTouchPos = (e) => {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: (clientX - rect.left) / currentScale, y: (clientY - rect.top) / currentScale };
            };

            const onStart = (e) => {
                if (roomStatus !== 'playing') return; // ğŸŒŸ å¿…é ˆåœ¨éŠç©ç‹€æ…‹æ‰èƒ½æ“ä½œ
                if (isMoving || currentTurn !== myTeam) return; 
                const pos = getTouchPos(e);
                let myPlayer = Matter.Query.point(players, pos).find(b => b.team === myTeam);
                if (myPlayer) {
                    dragState.isDragging = true; dragState.player = myPlayer;
                    dragState.startX = pos.x; dragState.startY = pos.y;
                    dragState.currentX = pos.x; dragState.currentY = pos.y;
                }
            };
            const onMove = (e) => {
                if(e.touches) e.preventDefault(); // é˜²æ­¢æ»‘å‹•
                if (!dragState.isDragging) return;
                const pos = getTouchPos(e);
                dragState.currentX = pos.x; dragState.currentY = pos.y;
            };
            const onEnd = () => {
                if (!dragState.isDragging) return;
                let dx = dragState.startX - dragState.currentX; let dy = dragState.startY - dragState.currentY;
                
                let pullDist = Math.sqrt(dx*dx + dy*dy); const maxPull = 200; 
                if (pullDist > maxPull) { dx = (dx/pullDist) * maxPull; dy = (dy/pullDist) * maxPull; }

                let forceMultiplier = 0.009; 
                let forceX = dx * forceMultiplier; let forceY = dy * forceMultiplier;

                // ğŸŒŸ ç™¼å°„å‰å†æ¬¡é©—è­‰é˜²é€£é»ä½œå¼Š
                if (gameMode === 'multi' && currentTurn !== myTeam) { dragState.isDragging = false; return; }

                applyAction(players.indexOf(dragState.player), forceX, forceY);
                if (gameMode === 'multi' && db) set(ref(db, `rooms/${currentRoom}/action`), { playerId: players.indexOf(dragState.player), forceX, forceY, timestamp: Date.now() });
                dragState.isDragging = false; dragState.player = null;
            };

            canvas.addEventListener('mousedown', onStart); canvas.addEventListener('mousemove', onMove); canvas.addEventListener('mouseup', onEnd);
            canvas.addEventListener('touchstart', onStart, {passive: false}); canvas.addEventListener('touchmove', onMove, {passive: false}); canvas.addEventListener('touchend', onEnd);
        }

        function applyAction(playerId, forceX, forceY) {
            const player = players[playerId];
            if (player) { Matter.Body.applyForce(player, player.position, { x: forceX, y: forceY }); isMoving = true; hideBanners(); }
        }

        function checkTurnState() {
            // ğŸŒŸ åš´æ ¼çš„ X è»¸èˆ‡ Y è»¸é€²çƒåˆ¤å®šï¼Œä¿è­‰åªæœ‰é€² U å‹é–€æ‰ç®—åˆ†
            let inGoalX = ball.position.x > leftW && ball.position.x < (gameWidth - leftW);
            if (inGoalX && ball.position.y < fieldTop - 5) scoreGoal('red'); 
            else if (inGoalX && ball.position.y > fieldBottom + 5) scoreGoal('blue');

            if (isMoving) {
                let totalSpeed = ball.speed + players.reduce((sum, p) => sum + p.speed, 0);
                if (totalSpeed < 0.4) { 
                    isMoving = false;
                    Matter.Body.setVelocity(ball, {x:0, y:0}); players.forEach(p => Matter.Body.setVelocity(p, {x:0, y:0}));
                    currentTurn = currentTurn === 'red' ? 'blue' : 'red';
                    if (gameMode === 'multi' && myTeam === 'red' && db) update(ref(db, `rooms/${currentRoom}`), { turn: currentTurn });
                    else if (gameMode === 'single') { updateTurnBanner(); if(currentTurn === 'blue') setTimeout(triggerBotAITurn, 800); }
                }
            }
        }

        function scoreGoal(team) {
            if (gameMode === 'multi' && myTeam !== 'red') return; 
            let newScores = { ...scores }; newScores[team] += 1;
            if (gameMode === 'multi' && db) update(ref(db, `rooms/${currentRoom}`), { scores: newScores, resetFlag: Date.now() });
            else { scores = newScores; updateScoreUI(); checkWin(team); if(scores[team] < WIN_SCORE) resetFormation(false); }
        }

        function checkWin(team) {
            if (scores[team] >= WIN_SCORE) {
                const isWin = (team === myTeam);
                document.getElementById('win-text').innerText = isWin ? "YOU WON!" : "YOU LOST!";
                document.getElementById('win-text').style.color = isWin ? '#ff6b6b' : '#4ea8de';
                document.getElementById('win-modal').style.display = 'flex';
                roomStatus = 'ended';
                if(gameMode === 'multi' && db && myTeam === 'red') update(ref(db, `rooms/${currentRoom}`), { status: 'ended' });
            }
        }

        function triggerBotAITurn() {
            if (currentTurn !== 'blue' || isMoving || roomStatus !== 'playing') return;
            let bot = null; let minDist = Infinity;
            players.filter(p => p.team === 'blue').forEach(p => {
                let dist = Vector.magnitude(Vector.sub(ball.position, p.position));
                if(dist < minDist){ bot = p; minDist = dist; }
            });
            if(bot) {
                let dir = Vector.normalise(Vector.sub(ball.position, bot.position));
                let errorAngle = (Math.random() - 0.5) * 0.15; let finalDir = Vector.rotate(dir, errorAngle);
                applyAction(players.indexOf(bot), finalDir.x * 0.7, finalDir.y * 0.7);
            }
        }

        function updateTurnBanner() {
            const bBot = document.getElementById('bot-banner'); const bPlayer = document.getElementById('player-banner');
            bBot.classList.remove('active'); bPlayer.classList.remove('active');
            clearTimeout(bannerTimer); 
            
            if(roomStatus !== 'playing' || isMoving) return;
            
            if (gameMode === 'single') { 
                if (currentTurn === 'red') bPlayer.classList.add('active'); else bBot.classList.add('active'); 
            } else {
                if (currentTurn === myTeam) { bPlayer.innerText = "YOUR TURN!"; bPlayer.classList.add('active'); } 
                else { bBot.innerText = "OPPONENT THINKING..."; bBot.classList.add('active'); }
            }

            bannerTimer = setTimeout(() => { bBot.classList.remove('active'); bPlayer.classList.remove('active'); }, 2000);
        }
        function hideBanners() { document.getElementById('bot-banner').classList.remove('active'); document.getElementById('player-banner').classList.remove('active'); }
        function updateScoreUI() { document.getElementById('score-red').innerText = scores.red; document.getElementById('score-blue').innerText = scores.blue; }

        // === é¸å–®èˆ‡æµç¨‹æ§åˆ¶ ===
        const menuContainer = document.getElementById('menu-container'); const gameUI = document.getElementById('game-ui');

        function exitToMenu() {
            if (gameMode === 'multi' && currentRoom && db) { set(ref(db, `rooms/${currentRoom}`), null); } // æ¸…é™¤æˆ¿é–“
            gameMode = 'single'; currentRoom = null; roomStatus = 'ended';
            document.getElementById('win-modal').style.display = 'none';
            document.getElementById('waiting-overlay').style.display = 'none';
            gameUI.style.display = 'none'; menuContainer.style.display = 'flex';
            if(engine) { Matter.Engine.clear(engine); Render.stop(render); Runner.stop(runner); }
        }

        document.getElementById('btn-exit').addEventListener('click', () => { if(confirm("ç¢ºå®šè¦é›¢é–‹éŠæˆ²å—ï¼Ÿ")) exitToMenu(); });
        document.getElementById('btn-home').addEventListener('click', exitToMenu);

        document.getElementById('btn-single').addEventListener('click', () => {
            gameMode = 'single'; myTeam = 'red'; roomStatus = 'playing';
            document.getElementById('p2-name').innerText = "BOT";
            document.getElementById('p2-name').style.color = "#4ea8de";
            menuContainer.style.display = 'none'; gameUI.style.display = 'flex'; initGame();
        });

        // ğŸŒŸ é˜²æ’è™Ÿå‰µå»ºèˆ‡æ–·ç·šä¿è­·
        async function generateRoom() {
            let roomId; let exists = true;
            while(exists) {
                roomId = Math.floor(1000 + Math.random() * 9000).toString();
                const snapshot = await get(ref(db, `rooms/${roomId}`));
                exists = snapshot.exists();
            }
            return roomId;
        }

        document.getElementById('btn-create').addEventListener('click', async () => {
            if(!db) { showToast("âš ï¸ Firebase æœªé€£ç·šï¼", true); return; }
            const btn = document.getElementById('btn-create');
            btn.innerText = "å‰µå»ºä¸­..."; btn.disabled = true;

            try {
                const roomId = await generateRoom();
                const roomRef = ref(db, `rooms/${roomId}`);
                await set(roomRef, { scores: { red: 0, blue: 0 }, turn: 'red', status: 'waiting' });
                
                // æ–·ç·šè‡ªå‹•åˆªé™¤æˆ¿é–“
                onDisconnect(roomRef).remove();

                gameMode = 'multi'; myTeam = 'red'; currentRoom = roomId; roomStatus = 'waiting';
                document.getElementById('p2-name').innerText = "OPPONENT";
                
                menuContainer.style.display = 'none'; gameUI.style.display = 'flex'; 
                document.getElementById('waiting-overlay').style.display = 'flex';
                document.getElementById('waiting-room-id').innerText = roomId;
                
                initGame(); listenToRoom();
                btn.innerText = "ğŸ‘¤ VS ğŸ‘¤ (å»ºç«‹)"; btn.disabled = false;
            } catch(e) {
                btn.innerText = "ğŸ‘¤ VS ğŸ‘¤ (å»ºç«‹)"; btn.disabled = false;
                showToast("âŒ å‰µå»ºå¤±æ•—ï¼Œè«‹æª¢æŸ¥æ¬Šé™", true);
            }
        });

        document.getElementById('btn-join').addEventListener('click', () => {
            if(!db) { showToast("âš ï¸ Firebase æœªé€£ç·šï¼", true); return; }
            const roomId = document.getElementById('input-room').value.trim();
            if (roomId.length !== 4) { showToast("è«‹è¼¸å…¥ 4 ä½æ•¸æˆ¿è™Ÿ", true); return; }
            
            const btn = document.getElementById('btn-join'); btn.innerText = "..."; btn.disabled = true;

            get(ref(db, `rooms/${roomId}`)).then((snapshot) => {
                btn.innerText = "GO"; btn.disabled = false;
                if (snapshot.exists() && snapshot.val().status === 'waiting') {
                    // åŠ å…¥æˆåŠŸï¼Œæ›´æ–°ç‹€æ…‹ç‚º playing
                    update(ref(db, `rooms/${roomId}`), { status: 'playing' });
                    // æ–·ç·šè‡ªå‹•åˆªé™¤æˆ¿é–“
                    onDisconnect(ref(db, `rooms/${roomId}`)).remove();

                    gameMode = 'multi'; myTeam = 'blue'; currentRoom = roomId; roomStatus = 'playing';
                    document.getElementById('p2-name').innerText = "HOST";
                    menuContainer.style.display = 'none'; gameUI.style.display = 'flex'; 
                    document.getElementById('waiting-overlay').style.display = 'none';
                    initGame(); listenToRoom();
                } else { showToast("âŒ æˆ¿é–“ä¸å­˜åœ¨æˆ–å·²æ»¿", true); }
            }).catch(e => { btn.innerText = "GO"; btn.disabled = false; showToast("åŠ å…¥å¤±æ•—", true); });
        });

        document.getElementById('btn-rematch').addEventListener('click', () => {
            document.getElementById('win-modal').style.display = 'none'; roomStatus = 'playing';
            if(gameMode === 'multi' && myTeam === 'red' && db) set(ref(db, `rooms/${currentRoom}`), { scores: { red: 0, blue: 0 }, turn: 'red', status: 'playing', resetFlag: Date.now() });
            else if (gameMode === 'single') resetFormation(true);
        });

        let lastActionTime = 0; let lastResetTime = 0;
        function listenToRoom() {
            onValue(ref(db, `rooms/${currentRoom}`), (snapshot) => {
                const data = snapshot.val(); 
                if (!data) {
                    // æˆ¿é–“è¢«åˆªé™¤ (å°æ‰‹é›¢é–‹)
                    if(roomStatus !== 'ended') { showToast("âš ï¸ å°æ‰‹å·²é›¢é–‹æˆ¿é–“", true); setTimeout(exitToMenu, 1500); }
                    return;
                }
                
                // ç‹€æ…‹åˆ‡æ›ï¼šå°æ‰‹åŠ å…¥
                if (roomStatus === 'waiting' && data.status === 'playing') {
                    roomStatus = 'playing'; document.getElementById('waiting-overlay').style.display = 'none'; updateTurnBanner();
                }

                scores = data.scores || { red: 0, blue: 0 }; updateScoreUI();
                if (data.status === 'ended' && document.getElementById('win-modal').style.display !== 'flex') { checkWin('red'); checkWin('blue'); }
                if (data.resetFlag && data.resetFlag > lastResetTime) { document.getElementById('win-modal').style.display = 'none'; resetFormation(true); lastResetTime = data.resetFlag; }
                if (data.turn && data.turn !== currentTurn && !isMoving && data.status === 'playing') { currentTurn = data.turn; updateTurnBanner(); }
            });
            onValue(ref(db, `rooms/${currentRoom}/action`), (snapshot) => {
                const action = snapshot.val();
                if (action && action.timestamp > lastActionTime) { lastActionTime = action.timestamp; applyAction(action.playerId, action.forceX, action.forceY); }
            });
        }
    </script>
</body>
</html>
