<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é€£ç·šç‰ˆå½ˆå¼“è¶³çƒ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <style>
        body {
            margin: 0; padding: 0;
            background-color: #2c3e50; color: white;
            font-family: sans-serif;
            display: flex; flex-direction: column; align-items: center;
            overflow-x: hidden;
        }
        #ui-container {
            text-align: center; margin-top: 20px; margin-bottom: 10px;
            width: 90%; max-width: 400px;
        }
        button {
            padding: 12px 20px; font-size: 16px; cursor: pointer;
            background-color: #e74c3c; color: white;
            border: none; border-radius: 8px; width: 100%;
            margin-bottom: 10px; box-sizing: border-box; font-weight: bold;
        }
        button:hover { background-color: #c0392b; }
        #single-btn { background-color: #f39c12; }
        #single-btn:hover { background-color: #d68910; }
        #join-btn { background-color: #3498db; }
        #join-btn:hover { background-color: #2980b9; }
        input {
            padding: 12px; font-size: 16px; width: 100%; margin-bottom: 10px;
            border-radius: 8px; border: 1px solid #ccc;
            box-sizing: border-box; text-align: center;
        }
        #game-container {
            border: 4px solid white; background-color: #27ae60;
            border-radius: 10px; position: relative;
            width: 100vw; max-width: 400px; aspect-ratio: 2 / 3; 
            overflow: hidden; display: none;
        }
        canvas { display: block; width: 100%; height: 100%; touch-action: none; }
        h1 { font-size: 24px; margin-bottom: 15px; }
        h2 { font-size: 18px; margin: 10px 0; }
        p { font-size: 16px; color: #f1c40f; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>âš½ å½ˆå¼“è¶³çƒå°æˆ°</h1>
        
        <div id="menu">
            <button id="single-btn">å–®äººéŠç© (Single Player vs AI)</button>
            <hr style="border:0; border-top:1px solid #7f8c8d; margin: 15px 0;">
            <button id="create-btn">å‰µå»ºé€£ç·šæˆ¿é–“ (Create Room)</button>
            <input type="text" id="room-input" placeholder="è¼¸å…¥æˆ¿è™Ÿ (Room ID)">
            <button id="join-btn">åŠ å…¥æˆ¿é–“ (Join Room)</button>
        </div>

        <div id="status" style="display:none;">
            <h2 id="room-display">å–®äººæ¨¡å¼</h2>
            <h2 id="score-display">ğŸ”´ ç´…éšŠ 0 - 0 è—éšŠ ğŸ”µ</h2>
            <p id="turn-display">æº–å‚™é–‹å§‹...</p>
        </div>
    </div>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, get } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCnONA7vSsBwOcui-bVBmmZfD_TOVZmck0",
            authDomain: "airplane-game-68f8f.firebaseapp.com",
            projectId: "airplane-game-68f8f",
            storageBucket: "airplane-game-68f8f.firebasestorage.app",
            messagingSenderId: "215248477446",
            appId: "1:215248477446:web:f1d9dbb69b759118125287",
            measurementId: "G-GKWZMFT66H",
            databaseURL: "https://airplane-game-68f8f-default-rtdb.firebaseio.com/" 
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // Game State (éŠæˆ²ç‹€æ…‹ï¼šè¨˜éŒ„ç•¶å‰éŠæˆ²æ¨¡å¼èˆ‡åˆ†æ•¸)
        let gameMode = 'single'; // 'single' æˆ– 'multi'
        let currentRoom = null;
        let playerColor = 'red'; 
        let isMyTurn = false;
        let scores = { red: 0, blue: 0 };

        const menuDiv = document.getElementById('menu');
        const statusDiv = document.getElementById('status');
        const gameContainer = document.getElementById('game-container');
        const roomDisplay = document.getElementById('room-display');
        const scoreDisplay = document.getElementById('score-display');
        const turnDisplay = document.getElementById('turn-display');
        const roomInput = document.getElementById('room-input');

        const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
              Bodies = Matter.Bodies, Composite = Matter.Composite, Events = Matter.Events,
              Mouse = Matter.Mouse, MouseConstraint = Matter.MouseConstraint, Vector = Matter.Vector;

        let engine, render, runner;
        let ball;
        let players = [];
        let slingshots = []; 

        const gameWidth = 400;
        const gameHeight = 600;

        function initPhysics() {
            engine = Engine.create();
            engine.world.gravity.y = 0; 
            
            render = Render.create({
                canvas: document.getElementById('game-canvas'),
                engine: engine,
                options: { width: gameWidth, height: gameHeight, wireframes: false, background: 'transparent' }
            });

            const walls = [
                Bodies.rectangle(gameWidth/2, -10, gameWidth, 20, { isStatic: true, render: { fillStyle: 'white' } }), 
                Bodies.rectangle(gameWidth/2, gameHeight+10, gameWidth, 20, { isStatic: true, render: { fillStyle: 'white' } }), 
                Bodies.rectangle(-10, gameHeight/2, 20, gameHeight, { isStatic: true, render: { fillStyle: 'white' } }), 
                Bodies.rectangle(gameWidth+10, gameHeight/2, 20, gameHeight, { isStatic: true, render: { fillStyle: 'white' } }) 
            ];
            
            const midline = Bodies.rectangle(gameWidth/2, gameHeight/2, gameWidth, 4, { 
                isStatic: true, isSensor: true, render: { fillStyle: 'rgba(255, 255, 255, 0.4)' } 
            });

            Composite.add(engine.world, [...walls, midline]);
            resetPositions();
            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);
            setupMouseInteraction();
        }

        function resetPositions() {
            if(ball) Composite.remove(engine.world, ball);
            players.forEach(p => Composite.remove(engine.world, p));
            slingshots.forEach(s => Composite.remove(engine.world, s));
            players = [];
            slingshots = [];

            ball = Bodies.circle(gameWidth/2, gameHeight/2, 12, { 
                restitution: 0.9, frictionAir: 0.015, render: { fillStyle: 'white' } 
            });
            Composite.add(engine.world, ball);

            const bluePositions = [
                {x: 150, y: 100}, {x: 250, y: 100}, 
                {x: 100, y: 180}, {x: 200, y: 180}, {x: 300, y: 180}, 
                {x: 150, y: 260}, {x: 250, y: 260} 
            ];
            
            const redPositions = [
                {x: 150, y: 500}, {x: 250, y: 500}, 
                {x: 100, y: 420}, {x: 200, y: 420}, {x: 300, y: 420}, 
                {x: 150, y: 340}, {x: 250, y: 340} 
            ];

            function createTeam(positions, color) {
                positions.forEach(pos => {
                    let player = Bodies.circle(pos.x, pos.y, 18, {
                        restitution: 0.5, frictionAir: 0.08,
                        render: { fillStyle: color === 'blue' ? '#3498db' : '#e74c3c' }, team: color
                    });
                    let tether = Matter.Constraint.create({
                        pointA: { x: pos.x, y: pos.y }, bodyB: player, stiffness: 0.05, render: { visible: false }
                    });
                    players.push(player);
                    slingshots.push(tether);
                    Composite.add(engine.world, [player, tether]);
                });
            }
            createTeam(bluePositions, 'blue');
            createTeam(redPositions, 'red');
        }

        function setupMouseInteraction() {
            const mouse = Mouse.create(render.canvas);
            const scaleX = render.canvas.width / render.canvas.clientWidth;
            const scaleY = render.canvas.height / render.canvas.clientHeight;
            Mouse.setScale(mouse, { x: scaleX, y: scaleY });

            const mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse, constraint: { stiffness: 0.2, render: { visible: false } }
            });
            Composite.add(engine.world, mouseConstraint);

            Events.on(mouseConstraint, 'startdrag', function(event) {
                const body = event.body;
                if (!isMyTurn || body.team !== playerColor || body === ball) {
                    mouseConstraint.body = null; 
                }
            });

            Events.on(mouseConstraint, 'enddrag', function(event) {
                if (!isMyTurn) return;
                const body = event.body;
                const tether = slingshots.find(s => s.bodyB === body);
                
                if (tether) {
                    const dx = body.position.x - tether.pointA.x;
                    const dy = body.position.y - tether.pointA.y;
                    const forceX = dx * -0.05;
                    const forceY = dy * -0.05;

                    if (gameMode === 'multi') {
                        // é€£ç·šæ¨¡å¼ï¼šå°‡å‹•ä½œé€åˆ° Firebase
                        set(ref(db, `rooms/${currentRoom}/action`), {
                            playerId: players.indexOf(body), forceX: forceX, forceY: forceY, timestamp: Date.now()
                        });
                        update(ref(db, `rooms/${currentRoom}`), { turn: playerColor === 'red' ? 'blue' : 'red' });
                    } else {
                        // å–®äººæ¨¡å¼ï¼šç›´æ¥åˆ‡æ›å›åˆä¸¦å‘¼å« AI
                        isMyTurn = false;
                        turnDisplay.innerText = "â³ ç­‰å¾… AI æ“ä½œ...";
                        setTimeout(triggerAITurn, 1500); // 1.5ç§’å¾Œ AI å‹•ä½œ
                    }
                }
            });
        }

        // --- AI Logic (äººå·¥æ™ºæ…§é‚è¼¯ï¼šæ§åˆ¶è—éšŠè‡ªå‹•æ‰“æ“Š) ---
        function triggerAITurn() {
            if (gameMode !== 'single') return;

            // å°‹æ‰¾è·é›¢çƒæœ€è¿‘çš„è—éšŠçƒå“¡
            let bestPlayer = null;
            let minDistance = Infinity;
            
            players.forEach(p => {
                if (p.team === 'blue') {
                    let dist = Vector.magnitude(Vector.sub(p.position, ball.position));
                    if (dist < minDistance) {
                        minDistance = dist;
                        bestPlayer = p;
                    }
                }
            });

            if (bestPlayer) {
                // è¨ˆç®—å¾çƒå“¡æŒ‡å‘çƒçš„å‘é‡ (Vector)
                let direction = Vector.normalise(Vector.sub(ball.position, bestPlayer.position));
                
                // æ¨¡æ“¬æ‹‰å‹•æ”¾é–‹çš„åŠ›é“ (Force)
                let power = 0.06; 
                Matter.Body.applyForce(bestPlayer, bestPlayer.position, {
                    x: direction.x * power,
                    y: direction.y * power
                });

                // åˆ‡æ›å›ç©å®¶å›åˆ
                setTimeout(() => {
                    isMyTurn = true;
                    turnDisplay.innerText = "ğŸ‘‰ æ›ä½ æ‹‰å‹•ç´…éšŠçƒå“¡ï¼";
                }, 1000);
            }
        }

        // --- åˆ†æ•¸åˆ¤å®š ---
        setInterval(() => {
            if (!ball) return;
            if (ball.position.y < 20) scoreGoal('red');
            else if (ball.position.y > gameHeight - 20) scoreGoal('blue');
        }, 500);

        function scoreGoal(team) {
            if (gameMode === 'multi') {
                if (playerColor !== 'red') return; // åªç”±æˆ¿ä¸»çµç®—
                let newScores = { ...scores };
                newScores[team] += 1;
                update(ref(db, `rooms/${currentRoom}`), { scores: newScores, resetFlag: Date.now() });
                checkWin(newScores, team);
            } else {
                // å–®äººæ¨¡å¼æœ¬åœ°çµç®—
                scores[team] += 1;
                updateScoreUI();
                resetPositions();
                checkWin(scores, team);
                
                // é€²çƒå¾Œé‡ç½®å›åˆ
                isMyTurn = true;
                turnDisplay.innerText = "ğŸ‘‰ æ›ä½ æ‹‰å‹•ç´…éšŠçƒå“¡ï¼";
            }
        }

        function checkWin(currentScores, team) {
            if (currentScores[team] >= 6) {
                alert(`${team === 'red' ? 'ğŸ”´ ç´…éšŠ' : 'ğŸ”µ è—éšŠ'} ç²å‹ï¼`);
                scores = { red: 0, blue: 0 };
                if (gameMode === 'multi') {
                    update(ref(db, `rooms/${currentRoom}`), { scores: scores });
                } else {
                    updateScoreUI();
                }
            }
        }

        function updateScoreUI() {
            scoreDisplay.innerText = `ğŸ”´ ç´…éšŠ ${scores.red} - ${scores.blue} è—éšŠ ğŸ”µ`;
        }

        // --- æŒ‰éˆ•äº‹ä»¶ç¶å®š ---
        
        document.getElementById('single-btn').addEventListener('click', () => {
            gameMode = 'single';
            playerColor = 'red';
            isMyTurn = true;
            scores = { red: 0, blue: 0 };
            menuDiv.style.display = 'none';
            statusDiv.style.display = 'block';
            gameContainer.style.display = 'block';
            roomDisplay.innerText = "æ¨¡å¼ï¼šå–®äººéŠç© (vs AI)";
            turnDisplay.innerText = "ğŸ‘‰ æ›ä½ æ‹‰å‹•ç´…éšŠçƒå“¡ï¼";
            updateScoreUI();
            initPhysics();
        });

        document.getElementById('create-btn').addEventListener('click', () => {
            gameMode = 'multi';
            const roomId = Math.random().toString(36).substring(2, 6).toUpperCase();
            
            // åŠ ä¸Š catch æ•æ‰ Firebase æ¬Šé™éŒ¯èª¤ (Permission Denied)
            set(ref(db, `rooms/${roomId}`), {
                status: 'waiting', turn: 'red', scores: { red: 0, blue: 0 }
            }).then(() => {
                currentRoom = roomId;
                playerColor = 'red'; 
                enterMultiplayerUI();
                listenToRoom();
            }).catch((error) => {
                alert("ç„¡æ³•å‰µå»ºæˆ¿é–“ï¼è«‹æª¢æŸ¥ Firebase çš„ Security Rules æ˜¯å¦è¨­å®šç‚º trueã€‚\néŒ¯èª¤è¨Šæ¯: " + error.message);
            });
        });

        document.getElementById('join-btn').addEventListener('click', () => {
            gameMode = 'multi';
            const roomId = roomInput.value.trim().toUpperCase();
            if (!roomId) return alert("è«‹è¼¸å…¥æˆ¿è™Ÿ");
            
            get(ref(db, `rooms/${roomId}`)).then((snapshot) => {
                if (snapshot.exists() && snapshot.val().status === 'waiting') {
                    currentRoom = roomId;
                    playerColor = 'blue'; 
                    update(ref(db, `rooms/${roomId}`), { status: 'playing' }).then(() => {
                        enterMultiplayerUI();
                        listenToRoom();
                    });
                } else {
                    alert("æˆ¿é–“ä¸å­˜åœ¨æˆ–éŠæˆ²å·²é–‹å§‹");
                }
            }).catch((error) => {
                alert("ç„¡æ³•é€£ç·šè‡³æˆ¿é–“ï¼è«‹æª¢æŸ¥ Firebase æ¬Šé™ã€‚\néŒ¯èª¤è¨Šæ¯: " + error.message);
            });
        });

        function enterMultiplayerUI() {
            menuDiv.style.display = 'none';
            statusDiv.style.display = 'block';
            gameContainer.style.display = 'block';
            roomDisplay.innerText = `é€£ç·šæˆ¿è™Ÿï¼š${currentRoom} (ä½ æ˜¯ ${playerColor === 'red' ? 'ğŸ”´ ç´…éšŠ' : 'ğŸ”µ è—éšŠ'})`;
            initPhysics();
        }

        let lastActionTime = 0;

        function listenToRoom() {
            onValue(ref(db, `rooms/${currentRoom}`), (snapshot) => {
                const data = snapshot.val();
                if (!data) return;

                scores = data.scores || { red: 0, blue: 0 };
                updateScoreUI();
                
                isMyTurn = (data.turn === playerColor);
                if (data.status === 'waiting') {
                    turnDisplay.innerText = "ç­‰å¾…å°æ‰‹åŠ å…¥...";
                    isMyTurn = false;
                } else {
                    turnDisplay.innerText = isMyTurn ? "ğŸ‘‰ æ›ä½ æ‹‰å‹•çƒå“¡ï¼" : "â³ ç­‰å¾…å°æ‰‹æ“ä½œ...";
                }

                if (data.resetFlag && data.resetFlag > lastActionTime) {
                    resetPositions();
                    lastActionTime = data.resetFlag;
                }
            });

            onValue(ref(db, `rooms/${currentRoom}/action`), (snapshot) => {
                const action = snapshot.val();
                if (action && action.timestamp > lastActionTime) {
                    lastActionTime = action.timestamp;
                    const targetPlayer = players[action.playerId];
                    if (targetPlayer) {
                        Matter.Body.applyForce(targetPlayer, targetPlayer.position, {
                            x: action.forceX, y: action.forceY
                        });
                    }
                }
            });
        }
    </script>
</body>
</html>
