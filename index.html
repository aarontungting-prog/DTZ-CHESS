<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é€£ç·šç‰ˆå½ˆå¼“è¶³çƒ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            color: white;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden; /* é˜²æ­¢å·¦å³æ»‘å‹• */
        }

        #ui-container {
            text-align: center;
            margin-top: 20px;
            margin-bottom: 10px;
            width: 90%;
            max-width: 400px;
        }

        button {
            padding: 12px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 8px;
            width: 100%;
            margin-bottom: 10px;
            box-sizing: border-box;
        }

        button:hover { background-color: #c0392b; }

        input {
            padding: 12px;
            font-size: 16px;
            width: 100%;
            margin-bottom: 10px;
            border-radius: 8px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            text-align: center;
        }

        #game-container {
            border: 4px solid white;
            background-color: #27ae60;
            border-radius: 10px;
            position: relative;
            /* Responsive Design (éŸ¿æ‡‰å¼è¨­è¨ˆï¼šè®“ç•«å¸ƒé©æ‡‰æ‰‹æ©Ÿè¢å¹•å¤§å°) */
            width: 100vw; 
            max-width: 400px;
            /* ä¿æŒ 2:3 çš„æ¯”ä¾‹ (400x600) */
            aspect-ratio: 2 / 3; 
            overflow: hidden;
            display: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* é—œéµï¼šé˜²æ­¢æ‰‹æ©Ÿæ‹–æ›³çƒå“¡æ™‚ç•«é¢è·Ÿè‘—æ²å‹• */
            touch-action: none; 
        }

        h1 { font-size: 24px; margin-bottom: 15px; }
        h2 { font-size: 18px; margin: 10px 0; }
        p { font-size: 16px; color: #f1c40f; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>âš½ å½ˆå¼“è¶³çƒå°æˆ°</h1>
        
        <div id="menu">
            <button id="create-btn">å‰µå»ºæˆ¿é–“ (Create Room)</button>
            <hr style="border:0; border-top:1px solid #7f8c8d; margin: 15px 0;">
            <input type="text" id="room-input" placeholder="è¼¸å…¥æˆ¿è™Ÿ (Room ID)">
            <button id="join-btn">åŠ å…¥æˆ¿é–“ (Join Room)</button>
        </div>

        <div id="status" style="display:none;">
            <h2 id="room-display">æˆ¿è™Ÿï¼š</h2>
            <h2 id="score-display">ğŸ”´ ç´…éšŠ 0 - 0 è—éšŠ ğŸ”µ</h2>
            <p id="turn-display">ç­‰å¾…å°æ‰‹åŠ å…¥...</p>
        </div>
    </div>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, get } from "https://www.gstatic.com/firebasejs/10.8.1/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCnONA7vSsBwOcui-bVBmmZfD_TOVZmck0",
            authDomain: "airplane-game-68f8f.firebaseapp.com",
            projectId: "airplane-game-68f8f",
            storageBucket: "airplane-game-68f8f.firebasestorage.app",
            messagingSenderId: "215248477446",
            appId: "1:215248477446:web:f1d9dbb69b759118125287",
            measurementId: "G-GKWZMFT66H",
            databaseURL: "https://airplane-game-68f8f-default-rtdb.firebaseio.com/" 
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        let currentRoom = null;
        let playerColor = null; 
        let isMyTurn = false;
        let scores = { red: 0, blue: 0 };

        const menuDiv = document.getElementById('menu');
        const statusDiv = document.getElementById('status');
        const gameContainer = document.getElementById('game-container');
        const roomDisplay = document.getElementById('room-display');
        const scoreDisplay = document.getElementById('score-display');
        const turnDisplay = document.getElementById('turn-display');
        const roomInput = document.getElementById('room-input');

        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Events = Matter.Events,
              Mouse = Matter.Mouse,
              MouseConstraint = Matter.MouseConstraint;

        let engine, render, runner;
        let ball;
        let players = [];
        let slingshots = []; 

        const gameWidth = 400;
        const gameHeight = 600;

        function initPhysics() {
            engine = Engine.create();
            engine.world.gravity.y = 0; 
            
            render = Render.create({
                canvas: document.getElementById('game-canvas'),
                engine: engine,
                options: {
                    width: gameWidth,
                    height: gameHeight,
                    wireframes: false, 
                    background: 'transparent'
                }
            });

            const walls = [
                Bodies.rectangle(gameWidth/2, 0, gameWidth, 20, { isStatic: true, render: { fillStyle: 'white' } }), 
                Bodies.rectangle(gameWidth/2, gameHeight, gameWidth, 20, { isStatic: true, render: { fillStyle: 'white' } }), 
                Bodies.rectangle(0, gameHeight/2, 20, gameHeight, { isStatic: true, render: { fillStyle: 'white' } }), 
                Bodies.rectangle(gameWidth, gameHeight/2, 20, gameHeight, { isStatic: true, render: { fillStyle: 'white' } }) 
            ];
            
            const midline = Bodies.rectangle(gameWidth/2, gameHeight/2, gameWidth, 5, { 
                isStatic: true, 
                isSensor: true, 
                render: { fillStyle: 'rgba(255, 255, 255, 0.5)' } 
            });

            Composite.add(engine.world, [...walls, midline]);

            resetPositions();

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);

            setupMouseInteraction();
        }

        function resetPositions() {
            if(ball) Composite.remove(engine.world, ball);
            players.forEach(p => Composite.remove(engine.world, p));
            slingshots.forEach(s => Composite.remove(engine.world, s));
            players = [];
            slingshots = [];

            ball = Bodies.circle(gameWidth/2, gameHeight/2, 12, { 
                restitution: 0.9, 
                frictionAir: 0.02, 
                render: { fillStyle: 'white' } 
            });
            Composite.add(engine.world, ball);

            const bluePositions = [
                {x: 150, y: 100}, {x: 250, y: 100}, 
                {x: 100, y: 180}, {x: 200, y: 180}, {x: 300, y: 180}, 
                {x: 150, y: 260}, {x: 250, y: 260} 
            ];
            
            const redPositions = [
                {x: 150, y: 500}, {x: 250, y: 500}, 
                {x: 100, y: 420}, {x: 200, y: 420}, {x: 300, y: 420}, 
                {x: 150, y: 340}, {x: 250, y: 340} 
            ];

            function createTeam(positions, color) {
                positions.forEach(pos => {
                    let player = Bodies.circle(pos.x, pos.y, 18, {
                        restitution: 0.6,
                        frictionAir: 0.05,
                        render: { fillStyle: color === 'blue' ? '#3498db' : '#e74c3c' },
                        team: color
                    });
                    
                    let tether = Matter.Constraint.create({
                        pointA: { x: pos.x, y: pos.y },
                        bodyB: player,
                        stiffness: 0.05, 
                        render: { visible: false }
                    });

                    players.push(player);
                    slingshots.push(tether);
                    Composite.add(engine.world, [player, tether]);
                });
            }

            createTeam(bluePositions, 'blue');
            createTeam(redPositions, 'red');
        }

        function setupMouseInteraction() {
            const mouse = Mouse.create(render.canvas);
            
            // è®“æ»‘é¼ /è§¸æ§é»æ“Šèˆ‡ Canvas çš„ç¸®æ”¾æ¯”ä¾‹æ­£ç¢ºå°æ‡‰
            const scaleX = render.canvas.width / render.canvas.clientWidth;
            const scaleY = render.canvas.height / render.canvas.clientHeight;
            Mouse.setScale(mouse, { x: scaleX, y: scaleY });

            const mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: { stiffness: 0.2, render: { visible: false } }
            });
            Composite.add(engine.world, mouseConstraint);

            Events.on(mouseConstraint, 'startdrag', function(event) {
                const body = event.body;
                if (!isMyTurn || body.team !== playerColor || body === ball) {
                    mouseConstraint.body = null; 
                }
            });

            Events.on(mouseConstraint, 'enddrag', function(event) {
                if (!isMyTurn) return;
                const body = event.body;
                
                const tether = slingshots.find(s => s.bodyB === body);
                if (tether) {
                    const dx = body.position.x - tether.pointA.x;
                    const dy = body.position.y - tether.pointA.y;
                    
                    const actionRef = ref(db, `rooms/${currentRoom}/action`);
                    set(actionRef, {
                        playerId: players.indexOf(body),
                        forceX: dx * -0.05, 
                        forceY: dy * -0.05,
                        timestamp: Date.now()
                    });

                    update(ref(db, `rooms/${currentRoom}`), { turn: playerColor === 'red' ? 'blue' : 'red' });
                }
            });
        }

        setInterval(() => {
            if (!ball) return;
            if (ball.position.y < 30) {
                scoreGoal('red');
            } else if (ball.position.y > gameHeight - 30) {
                scoreGoal('blue');
            }
        }, 500);

        function scoreGoal(team) {
            if (playerColor !== 'red') return; 
            let newScores = { ...scores };
            newScores[team] += 1;
            update(ref(db, `rooms/${currentRoom}`), { scores: newScores, resetFlag: Date.now() });

            if (newScores[team] >= 6) {
                alert(`${team === 'red' ? 'ç´…' : 'è—'}éšŠç²å‹ï¼`);
                update(ref(db, `rooms/${currentRoom}`), { scores: { red: 0, blue: 0 } });
            }
        }

        document.getElementById('create-btn').addEventListener('click', () => {
            const roomId = Math.random().toString(36).substring(2, 6).toUpperCase();
            currentRoom = roomId;
            playerColor = 'red'; 
            
            set(ref(db, `rooms/${roomId}`), {
                status: 'waiting',
                turn: 'red',
                scores: { red: 0, blue: 0 }
            }).then(() => {
                enterGameUI();
                listenToRoom();
            });
        });

        document.getElementById('join-btn').addEventListener('click', () => {
            const roomId = roomInput.value.trim().toUpperCase();
            if (!roomId) return alert("è«‹è¼¸å…¥æˆ¿è™Ÿ");
            
            get(ref(db, `rooms/${roomId}`)).then((snapshot) => {
                if (snapshot.exists() && snapshot.val().status === 'waiting') {
                    currentRoom = roomId;
                    playerColor = 'blue'; 
                    
                    update(ref(db, `rooms/${roomId}`), { status: 'playing' }).then(() => {
                        enterGameUI();
                        listenToRoom();
                    });
                } else {
                    alert("æˆ¿é–“ä¸å­˜åœ¨æˆ–å·²æ»¿");
                }
            });
        });

        function enterGameUI() {
            menuDiv.style.display = 'none';
            statusDiv.style.display = 'block';
            gameContainer.style.display = 'block';
            roomDisplay.innerText = `æˆ¿è™Ÿï¼š${currentRoom} (ä½ æ˜¯ ${playerColor === 'red' ? 'ğŸ”´ ç´…éšŠ' : 'ğŸ”µ è—éšŠ'})`;
            initPhysics();
        }

        let lastActionTime = 0;

        function listenToRoom() {
            onValue(ref(db, `rooms/${currentRoom}`), (snapshot) => {
                const data = snapshot.val();
                if (!data) return;

                scores = data.scores || { red: 0, blue: 0 };
                scoreDisplay.innerText = `ğŸ”´ ç´…éšŠ ${scores.red} - ${scores.blue} è—éšŠ ğŸ”µ`;
                
                isMyTurn = (data.turn === playerColor);
                if (data.status === 'waiting') {
                    turnDisplay.innerText = "ç­‰å¾…å°æ‰‹åŠ å…¥...";
                    isMyTurn = false;
                } else {
                    turnDisplay.innerText = isMyTurn ? "ğŸ‘‰ æ›ä½ æ‹‰å‹•çƒå“¡ï¼" : "â³ ç­‰å¾…å°æ‰‹æ“ä½œ...";
                }

                if (data.resetFlag && data.resetFlag > lastActionTime) {
                    resetPositions();
                    lastActionTime = data.resetFlag;
                }
            });

            onValue(ref(db, `rooms/${currentRoom}/action`), (snapshot) => {
                const action = snapshot.val();
                if (action && action.timestamp > lastActionTime) {
                    lastActionTime = action.timestamp;
                    const targetPlayer = players[action.playerId];
                    if (targetPlayer) {
                        Matter.Body.applyForce(targetPlayer, targetPlayer.position, {
                            x: action.forceX,
                            y: action.forceY
                        });
                    }
                }
            });
        }
    </script>
</body>
</html>
